diff -uNar CodeGen.old/BranchFolding.cpp CodeGen.new/BranchFolding.cpp
--- CodeGen.old/BranchFolding.cpp	2019-08-20 18:14:10.907267093 +0800
+++ CodeGen.new/BranchFolding.cpp	2019-08-20 18:13:18.119266102 +0800
@@ -65,6 +65,7 @@
 using namespace llvm;
 
 #define DEBUG_TYPE "branch-folder"
+#define LLVM_DEBUG2(X) do { X; } while (false)
 
 STATISTIC(NumDeadBlocks, "Number of dead blocks removed");
 STATISTIC(NumBranchOpts, "Number of branches optimized");
@@ -113,12 +114,32 @@
 
 char &llvm::BranchFolderPassID = BranchFolderPass::ID;
 
+static std::string getBlockName(const MachineBasicBlock *BB) {
+  std::string Result;
+  raw_string_ostream OS(Result);
+  OS << printMBBReference(*BB);
+  OS << " ('" << BB->getName() << "')";
+  OS << " ('" << BB->getFullName().c_str() << "')";
+  OS << " ('" << BB->getNumber() << "')";
+  OS.flush();
+  return Result;
+}
 INITIALIZE_PASS(BranchFolderPass, DEBUG_TYPE,
                 "Control Flow Optimizer", false, false)
 
 bool BranchFolderPass::runOnMachineFunction(MachineFunction &MF) {
+  dbgs() << "BranchFolderPass::runOnMachineFunction\n";
   if (skipFunction(MF.getFunction()))
     return false;
+  for (MachineBasicBlock &BB : MF) {
+    dbgs() << "In BB: " << getBlockName(&BB) << "   size: " << BB.succ_size() << "\n";
+    for (MachineBasicBlock *Succ : BB.successors()) {
+      dbgs() << "  Succ: " << getBlockName(Succ) << "   size: " << Succ->succ_size() << "\n";
+    }
+    for (MachineBasicBlock *PreSucc : BB.predecessors()) {
+      dbgs() << "  PreSucc: " << getBlockName(PreSucc) << "   size: " << PreSucc->succ_size() << "\n";
+    }
+  }
 
   TargetPassConfig *PassConfig = &getAnalysis<TargetPassConfig>();
   // TailMerge can create jump into if branches that make CFG irreducible for
@@ -151,7 +172,7 @@
 
 void BranchFolder::RemoveDeadBlock(MachineBasicBlock *MBB) {
   assert(MBB->pred_empty() && "MBB must be dead!");
-  LLVM_DEBUG(dbgs() << "\nRemoving MBB: " << *MBB);
+  LLVM_DEBUG2(dbgs() << "\nRemoving MBB: " << *MBB);
 
   MachineFunction *MF = MBB->getParent();
   // drop all successors.
@@ -239,6 +260,15 @@
       MadeChange = true;
     }
 
+  for (MachineBasicBlock &BB : MF) {
+    dbgs() << "out: BB: " << getBlockName(&BB) << "   size: " << BB.succ_size() << "\n";
+    for (MachineBasicBlock *Succ : BB.successors()) {
+      dbgs() << "  Succ: " << getBlockName(Succ) << "   size: " << Succ->succ_size() << "\n";
+    }
+    for (MachineBasicBlock *PreSucc : BB.predecessors()) {
+      dbgs() << "  PreSucc: " << getBlockName(PreSucc) << "   size: " << PreSucc->succ_size() << "\n";
+    }
+  }
   return MadeChange;
 }
 
@@ -297,6 +327,16 @@
 
 ///  Whether MI should be counted as an instruction when calculating common tail.
 static bool countsAsInstruction(const MachineInstr &MI) {
+  if (MI.isDebugInstr())
+    dbgs() << "chris debugInstr=1\n";
+  else
+    dbgs() << "chris debugInstr=0\n";
+
+  if (MI.isCFIInstruction())
+    dbgs() << "chris CFIInstruction=1\n";
+  else
+    dbgs() << "chris CFIInstruction=0\n";
+
   return !(MI.isDebugInstr() || MI.isCFIInstruction());
 }
 
@@ -309,34 +349,49 @@
                                         MachineBasicBlock::iterator &I2) {
   I1 = MBB1->end();
   I2 = MBB2->end();
+  dbgs() << "chris: MBB1: " << *MBB1 << "\n";
+  dbgs() << "chris: MBB2: " << *MBB2 << "\n";
+  dbgs() << "chris: I1 begin: " << *MBB1->begin() << "\n";
+  dbgs() << "chris: I2 begin: " << *MBB2->begin() << "\n";
+  dbgs() << "chris: I1 end: " << *MBB1->end() << "\n";
+  dbgs() << "chris: I2 end: " << *MBB2->end() << "\n";
 
   unsigned TailLen = 0;
   while (I1 != MBB1->begin() && I2 != MBB2->begin()) {
     --I1; --I2;
     // Skip debugging pseudos; necessary to avoid changing the code.
+    dbgs() << "chris: I1: " << *I1 << "\n";
+    dbgs() << "chris: I2: " << *I2 << "\n";
     while (!countsAsInstruction(*I1)) {
+      dbgs() << "chris: while I1: " << *I1 << "\n";
       if (I1==MBB1->begin()) {
         while (!countsAsInstruction(*I2)) {
           if (I2==MBB2->begin()) {
             // I1==DBG at begin; I2==DBG at begin
+            dbgs() << "chris: point99 I2: " << *I2 << "\n";
             goto SkipTopCFIAndReturn;
           }
           --I2;
+          dbgs() << "chris: point10 I2: " << *I2 << "\n";
         }
         ++I2;
+        dbgs() << "chris: point11 I2: " << *I2 << "\n";
         // I1==DBG at begin; I2==non-DBG, or first of DBGs not at begin
         goto SkipTopCFIAndReturn;
       }
       --I1;
     }
+      dbgs() << "chris: while I1: " << *I1 << "\n";
     // I1==first (untested) non-DBG preceding known match
     while (!countsAsInstruction(*I2)) {
+      dbgs() << "chris: while I2: " << *I2 << "\n";
       if (I2==MBB2->begin()) {
         ++I1;
         // I1==non-DBG, or first of DBGs not at begin; I2==DBG at begin
         goto SkipTopCFIAndReturn;
       }
       --I2;
+      dbgs() << "chris: point12 I2: " << *I2 << "\n";
     }
     // I1, I2==first (untested) non-DBGs preceding known match
     if (!I1->isIdenticalTo(*I2) ||
@@ -347,6 +402,7 @@
         // directives.
         I1->isInlineAsm()) {
       ++I1; ++I2;
+      dbgs() << "chris: point1 I2: " << *I2 << "\n";
       break;
     }
     ++TailLen;
@@ -357,12 +413,15 @@
   // I1==MBB1->begin() work as expected.)
   if (I1 == MBB1->begin() && I2 != MBB2->begin()) {
     --I2;
+    dbgs() << "chris: point2 I2: " << *I2 << "\n";
     while (I2->isDebugInstr()) {
       if (I2 == MBB2->begin())
         return TailLen;
       --I2;
+      dbgs() << "chris: point3 I2: " << *I2 << "\n";
     }
     ++I2;
+    dbgs() << "chris: point4 I2: " << *I2 << "\n";
   }
   if (I2 == MBB2->begin() && I1 != MBB1->begin()) {
     --I1;
@@ -400,7 +459,8 @@
     ++I1;
   }
 
-  while (I2 != MBB2->end() && I2->isCFIInstruction()) {
+//countsAsInstruction
+  while (I2 != MBB2->end() && (I2->isCFIInstruction() || I2->isDebugInstr())) {
     ++I2;
   }
 
@@ -647,9 +707,17 @@
   }
 
   CommonTailLen = ComputeCommonTailLength(MBB1, MBB2, I1, I2);
+
+
+  dbgs() << "chris-ComputeCommonTailLength \n";
+  dbgs() << "   MBB1: " << *MBB1 << "\n";
+  dbgs() << "   MBB2: " << *MBB2 << "\n";
+  //dbgs() << "   I1: " << *I1 << "\n";
+  dbgs() << "   I2: " << *I2 << "\n";
+
   if (CommonTailLen == 0)
     return false;
-  LLVM_DEBUG(dbgs() << "Common tail length of " << printMBBReference(*MBB1)
+  LLVM_DEBUG2(dbgs() << "Common tail length of " << printMBBReference(*MBB1)
                     << " and " << printMBBReference(*MBB2) << " is "
                     << CommonTailLen << '\n');
 
@@ -744,15 +812,21 @@
                             SuccBB, PredBB,
                             EHScopeMembership,
                             AfterBlockPlacement)) {
+        dbgs() << "chris-SameTails 1 " << *TrialBBI1 << "\n";
+        dbgs() << "chris-SameTails 2 " << *TrialBBI2 << "\n";
         if (CommonTailLen > maxCommonTailLength) {
           SameTails.clear();
           maxCommonTailLength = CommonTailLen;
           HighestMPIter = CurMPIter;
           SameTails.push_back(SameTailElt(CurMPIter, TrialBBI1));
+          dbgs() << "chris-SameTails push 1 " << *TrialBBI1 << "\n";
         }
         if (HighestMPIter == CurMPIter &&
             CommonTailLen == maxCommonTailLength)
+         {
           SameTails.push_back(SameTailElt(I, TrialBBI2));
+          dbgs() << "chris-SameTails push 2 " << *TrialBBI2 << "\n";
+         }
       }
       if (I == B)
         break;
@@ -806,7 +880,7 @@
     SameTails[commonTailIndex].getTailStartPos();
   MachineBasicBlock *MBB = SameTails[commonTailIndex].getBlock();
 
-  LLVM_DEBUG(dbgs() << "\nSplitting " << printMBBReference(*MBB) << ", size "
+  LLVM_DEBUG2(dbgs() << "\nSplitting " << printMBBReference(*MBB) << ", size "
                     << maxCommonTailLength);
 
   // If the split block unconditionally falls-thru to SuccBB, it will be
@@ -816,7 +890,7 @@
     SuccBB->getBasicBlock() : MBB->getBasicBlock();
   MachineBasicBlock *newMBB = SplitMBBAt(*MBB, BBI, BB);
   if (!newMBB) {
-    LLVM_DEBUG(dbgs() << "... failed!");
+    LLVM_DEBUG2(dbgs() << "... failed!");
     return false;
   }
 
@@ -956,7 +1030,10 @@
                                       unsigned MinCommonTailLength) {
   bool MadeChange = false;
 
-  LLVM_DEBUG(
+      dbgs() << "chris-TryTailMergeBlocks: SuccBB= " << printMBBReference(*SuccBB) <<
+          "  PredBB= " << printMBBReference(*PredBB) << "length=" << MinCommonTailLength;
+
+  LLVM_DEBUG2(
       dbgs() << "\nTryTailMergeBlocks: ";
       for (unsigned i = 0, e = MergePotentials.size(); i != e; ++i) dbgs()
       << printMBBReference(*MergePotentials[i].getBlock())
@@ -998,38 +1075,61 @@
     MachineBasicBlock *EntryBB =
         &MergePotentials.front().getBlock()->getParent()->front();
     unsigned commonTailIndex = SameTails.size();
+    dbgs() << "chris1 commonTailIndex= " << commonTailIndex << "\n";
+    dbgs() << "chris1 EntryBB = " << printMBBReference(*EntryBB) << "\n";
+    dbgs() << "chris1 PredBB = " << printMBBReference(*PredBB) << "\n";
     // If there are two blocks, check to see if one can be made to fall through
     // into the other.
     if (SameTails.size() == 2 &&
         SameTails[0].getBlock()->isLayoutSuccessor(SameTails[1].getBlock()) &&
         SameTails[1].tailIsWholeBlock())
+    {
       commonTailIndex = 1;
+      dbgs() << "chris2 commonTailIndex= " << commonTailIndex << "\n";
+    }
     else if (SameTails.size() == 2 &&
              SameTails[1].getBlock()->isLayoutSuccessor(
                                                      SameTails[0].getBlock()) &&
              SameTails[0].tailIsWholeBlock())
+     {
       commonTailIndex = 0;
+      dbgs() << "chris3 commonTailIndex= " << commonTailIndex << "\n";
+    }
     else {
       // Otherwise just pick one, favoring the fall-through predecessor if
       // there is one.
       for (unsigned i = 0, e = SameTails.size(); i != e; ++i) {
         MachineBasicBlock *MBB = SameTails[i].getBlock();
+        LLVM_DEBUG2(dbgs() << "chris_MBB1: " << printMBBReference(*MBB)<< " i:" << i << "\n");
+        dbgs() << "SameTails[i]. get block = " << *SameTails[i].getBlock() << "\n";
+        dbgs() << "getBlock()->begin(): " << *SameTails[i].getBlock()->begin() << "\n";
+        dbgs() << "getTailStartPos: " << *SameTails[i].getTailStartPos() << "\n";
+        dbgs() << "SameTails[i].tailIsWholeBlock() = " << SameTails[i].tailIsWholeBlock() << "\n";
         if (MBB == EntryBB && SameTails[i].tailIsWholeBlock())
           continue;
         if (MBB == PredBB) {
           commonTailIndex = i;
+          dbgs() << "chris4 commonTailIndex= " << commonTailIndex << "\n";
           break;
         }
         if (SameTails[i].tailIsWholeBlock())
+        {
           commonTailIndex = i;
+          dbgs() << "chris5 commonTailIndex= " << commonTailIndex << "\n";
+        }
       }
     }
 
+    dbgs() << "index: " << commonTailIndex << " vs " << SameTails.size() << "\n";
+    //dbgs() << "PredBB: " << printMBBReference(*SameTails[commonTailIndex].getBlock()) << " =? " << printMBBReference(*PredBB) << "\n";
+    //dbgs() << "tail is whole block: " << SameTails[commonTailIndex].tailIsWholeBlock() << "\n";
     if (commonTailIndex == SameTails.size() ||
         (SameTails[commonTailIndex].getBlock() == PredBB &&
          !SameTails[commonTailIndex].tailIsWholeBlock())) {
       // None of the blocks consist entirely of the common tail.
       // Split a block so that one does.
+      LLVM_DEBUG2(dbgs() << "PredBB: " << printMBBReference(*PredBB));
+      LLVM_DEBUG2(dbgs() << "  SuccBB: " << printMBBReference(*SuccBB) << "\n");
       if (!CreateCommonTailOnlyBlock(PredBB, SuccBB,
                                      maxCommonTailLength, commonTailIndex)) {
         RemoveBlocksWithHash(CurHash, SuccBB, PredBB);
@@ -1038,9 +1138,11 @@
     }
 
     MachineBasicBlock *MBB = SameTails[commonTailIndex].getBlock();
+    LLVM_DEBUG2(dbgs() << "chris_MBB2: " << printMBBReference(*MBB) << "\n");
 
     // Recompute common tail MBB's edge weights and block frequency.
     setCommonTailEdgeWeights(*MBB);
+    LLVM_DEBUG2(dbgs() << "chris_MBB3:\n " << printMBBReference(*MBB) << "\n");
 
     // Merge debug locations, MMOs and undef flags across identical instructions
     // for common tail.
@@ -1048,19 +1150,19 @@
 
     // MBB is common tail.  Adjust all other BB's to jump to this one.
     // Traversal must be forwards so erases work.
-    LLVM_DEBUG(dbgs() << "\nUsing common tail in " << printMBBReference(*MBB)
+    LLVM_DEBUG2(dbgs() << "\nUsing common tail in " << printMBBReference(*MBB)
                       << " for ");
     for (unsigned int i=0, e = SameTails.size(); i != e; ++i) {
       if (commonTailIndex == i)
         continue;
-      LLVM_DEBUG(dbgs() << printMBBReference(*SameTails[i].getBlock())
+      LLVM_DEBUG2(dbgs() << printMBBReference(*SameTails[i].getBlock())
                         << (i == e - 1 ? "" : ", "));
       // Hack the end off BB i, making it jump to BB commonTailIndex instead.
       replaceTailWithBranchTo(SameTails[i].getTailStartPos(), *MBB);
       // BB i is no longer a predecessor of SuccBB; remove it from the worklist.
       MergePotentials.erase(SameTails[i].getMPIter());
     }
-    LLVM_DEBUG(dbgs() << "\n");
+    LLVM_DEBUG2(dbgs() << "\n");
     // We leave commonTailIndex in the worklist in case there are other blocks
     // that match it with a smaller number of instructions.
     MadeChange = true;
@@ -1341,7 +1443,7 @@
   for (MachineInstr &MI : MBB.instrs())
     if (MI.isDebugInstr()) {
       TII->duplicate(PredMBB, InsertBefore, MI);
-      LLVM_DEBUG(dbgs() << "Copied debug entity from empty block to pred: "
+      LLVM_DEBUG2(dbgs() << "Copied debug entity from empty block to pred: "
                         << MI);
     }
 }
@@ -1353,7 +1455,7 @@
   for (MachineInstr &MI : MBB.instrs())
     if (MI.isDebugInstr()) {
       TII->duplicate(SuccMBB, InsertBefore, MI);
-      LLVM_DEBUG(dbgs() << "Copied debug entity from empty block to succ: "
+      LLVM_DEBUG2(dbgs() << "Copied debug entity from empty block to succ: "
                         << MI);
     }
 }
@@ -1469,7 +1571,7 @@
     if (PriorCond.empty() && !PriorTBB && MBB->pred_size() == 1 &&
         PrevBB.succ_size() == 1 &&
         !MBB->hasAddressTaken() && !MBB->isEHPad()) {
-      LLVM_DEBUG(dbgs() << "\nMerging into block: " << PrevBB
+      LLVM_DEBUG2(dbgs() << "\nMerging into block: " << PrevBB
                         << "From MBB: " << *MBB);
       // Remove redundant DBG_VALUEs first.
       if (PrevBB.begin() != PrevBB.end()) {
@@ -1556,7 +1658,7 @@
         // Reverse the branch so we will fall through on the previous true cond.
         SmallVector<MachineOperand, 4> NewPriorCond(PriorCond);
         if (!TII->reverseBranchCondition(NewPriorCond)) {
-          LLVM_DEBUG(dbgs() << "\nMoving MBB: " << *MBB
+          LLVM_DEBUG2(dbgs() << "\nMoving MBB: " << *MBB
                             << "To make fallthrough to: " << *PriorTBB << "\n");
 
           DebugLoc dl = getBranchDebugLoc(PrevBB);
diff -uNar CodeGen.old/BranchFolding.h CodeGen.new/BranchFolding.h
--- CodeGen.old/BranchFolding.h	2019-08-20 18:14:10.907267093 +0800
+++ CodeGen.new/BranchFolding.h	2019-08-20 18:13:18.119266102 +0800
@@ -105,6 +105,9 @@
       }
 
       bool tailIsWholeBlock() const {
+        dbgs() << "tailIsWholeblock:\n " <<
+              "     TailStartPos:        " << *TailStartPos
+           << "     getBlock()->begin(): " << *getBlock()->begin() << "\n";
         return TailStartPos == getBlock()->begin();
       }
 
@@ -113,6 +116,7 @@
       }
 
       void setTailStartPos(MachineBasicBlock::iterator Pos) {
+        dbgs() << "chris-setTailStartPos: " << *Pos << "\n";
         TailStartPos = Pos;
       }
     };
diff -uNar CodeGen.old/MachineBlockPlacement.cpp CodeGen.new/MachineBlockPlacement.cpp
--- CodeGen.old/MachineBlockPlacement.cpp	2019-08-20 18:14:10.907267093 +0800
+++ CodeGen.new/MachineBlockPlacement.cpp	2019-08-20 18:13:18.235266104 +0800
@@ -71,6 +71,8 @@
 using namespace llvm;
 
 #define DEBUG_TYPE "block-placement"
+#undef NDEBUG
+#define LLVM_DEBUG2(X) do { X; } while (false)
 
 STATISTIC(NumCondBranches, "Number of conditional branches");
 STATISTIC(NumUncondBranches, "Number of unconditional branches");
@@ -556,6 +558,8 @@
   raw_string_ostream OS(Result);
   OS << printMBBReference(*BB);
   OS << " ('" << BB->getName() << "')";
+  OS << " ('" << BB->getFullName().c_str() << "')";
+  OS << " ('" << BB->getNumber() << "')";
   OS.flush();
   return Result;
 }
@@ -572,6 +576,7 @@
     const BlockFilterSet *BlockFilter) {
   // Walk all the blocks in this chain, marking their successors as having
   // a predecessor placed.
+  dbgs() <<"chris: MachineBlockPlacement::markChainSuccessors\n";
   for (MachineBasicBlock *MBB : Chain) {
     markBlockSuccessors(Chain, MBB, LoopHeaderBB, BlockFilter);
   }
@@ -590,6 +595,7 @@
   // predecessor to the worklist as a viable candidate for CFG-neutral
   // placement. No subsequent placement of this block will violate the CFG
   // shape, so we get to use heuristics to choose a favorable placement.
+  dbgs() <<"chris: MachineBlockPlacement::markBlockSuccessors\n";
   for (MachineBasicBlock *Succ : MBB->successors()) {
     if (BlockFilter && !BlockFilter->count(Succ))
       continue;
@@ -636,6 +642,7 @@
   // HotProb to break topo-order). If we exclude E that is not in BlockFilter
   // when calculating the probability of C->D, D will be selected and we
   // will get A C D B as the layout of this loop.
+  dbgs() <<"chris: MachineBlockPlacement::collectViableSuccessors\n";
   auto AdjustedSumProb = BranchProbability::getOne();
   for (MachineBasicBlock *Succ : BB->successors()) {
     bool SkipSucc = false;
@@ -646,8 +653,9 @@
       if (SuccChain == &Chain) {
         SkipSucc = true;
       } else if (Succ != *SuccChain->begin()) {
-        LLVM_DEBUG(dbgs() << "    " << getBlockName(Succ)
+        LLVM_DEBUG2(dbgs() << "    " << getBlockName(Succ)
                           << " -> Mid chain!\n");
+        dbgs() <<"chris: blockName: %s\n", getBlockName(Succ).c_str();
         continue;
       }
     }
@@ -698,8 +706,10 @@
   // Blocks with single successors don't create additional fallthrough
   // opportunities. Don't duplicate them. TODO: When conditional exits are
   // analyzable, allow them to be duplicated.
+  dbgs() <<"chris: main: MachineBlockPlacement::shouldTailDuplicate\n";
   bool IsSimple = TailDup.isSimpleBB(BB);
 
+  dbgs() <<"chris: BB->succ_size =" << BB->succ_size() << "name: " << getBlockName(BB) << "\n";
   if (BB->succ_size() == 1)
     return false;
   return TailDup.shouldTailDuplicate(IsSimple, *BB);
@@ -749,6 +759,7 @@
   // fallthrough of Succ into either D or PDom, because they now have C as an
   // unplaced predecessor
 
+  dbgs() <<"chris: MachineBlockPlacement::isProfitableToTailDup\n";
   // Start by figuring out which case we fall into
   MachineBasicBlock *PDom = nullptr;
   SmallVector<MachineBasicBlock *, 4> SuccSuccs;
@@ -883,6 +894,7 @@
     const BlockChain &Chain, const BlockFilterSet *BlockFilter) {
   // Technically BB could form a trellis with branching factor higher than 2.
   // But that's extremely uncommon.
+  dbgs() <<"chris: MachineBlockPlacement::isTrellis\n";
   if (BB->succ_size() != 2 || ViableSuccs.size() != 2)
     return false;
 
@@ -1014,7 +1026,7 @@
     // If we have a trellis, and BB doesn't have the best fallthrough edges,
     // we shouldn't choose any successor. We've already looked and there's a
     // better fallthrough edge for all the successors.
-    LLVM_DEBUG(dbgs() << "Trellis, but not one of the chosen edges.\n");
+    LLVM_DEBUG2(dbgs() << "Trellis, but not one of the chosen edges.\n");
     return Result;
   }
 
@@ -1027,11 +1039,12 @@
     MachineBasicBlock *Succ1 = BestA.Dest;
     MachineBasicBlock *Succ2 = BestB.Dest;
     // Check to see if tail-duplication would be profitable.
+    dbgs() << "chris: shouldTailDuplicate point1\n";
     if (allowTailDupPlacement() && shouldTailDuplicate(Succ2) &&
         canTailDuplicateUnplacedPreds(BB, Succ2, Chain, BlockFilter) &&
         isProfitableToTailDup(BB, Succ2, MBPI->getEdgeProbability(BB, Succ1),
                               Chain, BlockFilter)) {
-      LLVM_DEBUG(BranchProbability Succ2Prob = getAdjustedProbability(
+      LLVM_DEBUG2(BranchProbability Succ2Prob = getAdjustedProbability(
                      MBPI->getEdgeProbability(BB, Succ2), AdjustedSumProb);
                  dbgs() << "    Selected: " << getBlockName(Succ2)
                         << ", probability: " << Succ2Prob
@@ -1046,7 +1059,7 @@
   ComputedEdges[BestB.Src] = { BestB.Dest, false };
 
   auto TrellisSucc = BestA.Dest;
-  LLVM_DEBUG(BranchProbability SuccProb = getAdjustedProbability(
+  LLVM_DEBUG2(BranchProbability SuccProb = getAdjustedProbability(
                  MBPI->getEdgeProbability(BB, TrellisSucc), AdjustedSumProb);
              dbgs() << "    Selected: " << getBlockName(TrellisSucc)
                     << ", probability: " << SuccProb << " (Trellis)\n");
@@ -1060,6 +1073,7 @@
 bool MachineBlockPlacement::canTailDuplicateUnplacedPreds(
     const MachineBasicBlock *BB, MachineBasicBlock *Succ,
     const BlockChain &Chain, const BlockFilterSet *BlockFilter) {
+  dbgs() << "chris: shouldTailDuplicate point2\n";
   if (!shouldTailDuplicate(Succ))
     return false;
 
@@ -1155,19 +1169,31 @@
   if (TriangleChainCount == 0)
     return;
 
-  LLVM_DEBUG(dbgs() << "Pre-computing triangle chains.\n");
+  LLVM_DEBUG2(dbgs() << "Pre-computing triangle chains.\n");
   // Map from last block to the chain that contains it. This allows us to extend
   // chains as we find new triangles.
   DenseMap<const MachineBasicBlock *, TriangleChain> TriangleChainMap;
   for (MachineBasicBlock &BB : *F) {
+    dbgs() << "BB: " << getBlockName(&BB) << "   size: " << BB.succ_size() << "\n";
+    for (MachineBasicBlock *Succ : BB.successors()) {
+      dbgs() << "  Succ: " << getBlockName(Succ) << "   size: " << Succ->succ_size() << "\n";
+    }
+    for (MachineBasicBlock *PreSucc : BB.predecessors()) {
+      dbgs() << "  PreSucc: " << getBlockName(PreSucc) << "   size: " << PreSucc->succ_size() << "\n";
+    }
+  }
+  for (MachineBasicBlock &BB : *F) {
     // If BB doesn't have 2 successors, it doesn't start a triangle.
+    dbgs() << "BB: " << getBlockName(&BB) << "   size: " << BB.succ_size() << "\n";
     if (BB.succ_size() != 2)
       continue;
     MachineBasicBlock *PDom = nullptr;
     for (MachineBasicBlock *Succ : BB.successors()) {
+      dbgs() << "Succ: " << getBlockName(Succ) << "   size: " << Succ->succ_size() << "\n";
       if (!MPDT->dominates(Succ, &BB))
         continue;
       PDom = Succ;
+      dbgs() << "PDom: " << getBlockName(PDom) << "   size: " << PDom->succ_size() << "\n";
       break;
     }
     // If BB doesn't have a post-dominating successor, it doesn't form a
@@ -1175,10 +1201,13 @@
     if (PDom == nullptr)
       continue;
     // If PDom has a hint that it is low probability, skip this triangle.
+    dbgs() << "PDom: probability =  " << MBPI->getEdgeProbability(&BB, PDom) << "\n";
+    dbgs() << "PDom: Branchprobability =  " << BranchProbability(50, 100) << "\n";
     if (MBPI->getEdgeProbability(&BB, PDom) < BranchProbability(50, 100))
       continue;
     // If PDom isn't eligible for duplication, this isn't the kind of triangle
     // we're looking for.
+    dbgs() << "chris: shouldTailDuplicate point3\n";
     if (!shouldTailDuplicate(PDom))
       continue;
     bool CanTailDuplicate = true;
@@ -1229,7 +1258,7 @@
     MachineBasicBlock *dst = Chain.Edges.back();
     Chain.Edges.pop_back();
     for (MachineBasicBlock *src : reverse(Chain.Edges)) {
-      LLVM_DEBUG(dbgs() << "Marking edge: " << getBlockName(src) << "->"
+      LLVM_DEBUG2(dbgs() << "Marking edge: " << getBlockName(src) << "->"
                         << getBlockName(dst)
                         << " as pre-computed based on triangles.\n");
 
@@ -1437,7 +1466,7 @@
   }
 
   if (BadCFGConflict) {
-    LLVM_DEBUG(dbgs() << "    Not a candidate: " << getBlockName(Succ) << " -> "
+    LLVM_DEBUG2(dbgs() << "    Not a candidate: " << getBlockName(Succ) << " -> "
                       << SuccProb << " (prob) (non-cold CFG conflict)\n");
     return true;
   }
@@ -1468,7 +1497,7 @@
   auto AdjustedSumProb =
       collectViableSuccessors(BB, Chain, BlockFilter, Successors);
 
-  LLVM_DEBUG(dbgs() << "Selecting best successor for: " << getBlockName(BB)
+  LLVM_DEBUG2(dbgs() << "Selecting best successor for: " << getBlockName(BB)
                     << "\n");
 
   // if we already precomputed the best successor for BB, return that if still
@@ -1505,23 +1534,24 @@
     if (hasBetterLayoutPredecessor(BB, Succ, SuccChain, SuccProb, RealSuccProb,
                                    Chain, BlockFilter)) {
       // If tail duplication would make Succ profitable, place it.
+      dbgs() << "chris: shouldTailDuplicate point4\n";
       if (allowTailDupPlacement() && shouldTailDuplicate(Succ))
         DupCandidates.push_back(std::make_tuple(SuccProb, Succ));
       continue;
     }
 
-    LLVM_DEBUG(
+    LLVM_DEBUG2(
         dbgs() << "    Candidate: " << getBlockName(Succ)
                << ", probability: " << SuccProb
                << (SuccChain.UnscheduledPredecessors != 0 ? " (CFG break)" : "")
                << "\n");
 
     if (BestSucc.BB && BestProb >= SuccProb) {
-      LLVM_DEBUG(dbgs() << "    Not the best candidate, continuing\n");
+      LLVM_DEBUG2(dbgs() << "    Not the best candidate, continuing\n");
       continue;
     }
 
-    LLVM_DEBUG(dbgs() << "    Setting it as best candidate\n");
+    LLVM_DEBUG2(dbgs() << "    Setting it as best candidate\n");
     BestSucc.BB = Succ;
     BestProb = SuccProb;
   }
@@ -1543,7 +1573,7 @@
       break;
     if (canTailDuplicateUnplacedPreds(BB, Succ, Chain, BlockFilter)
         && (isProfitableToTailDup(BB, Succ, BestProb, Chain, BlockFilter))) {
-      LLVM_DEBUG(dbgs() << "    Candidate: " << getBlockName(Succ)
+      LLVM_DEBUG2(dbgs() << "    Candidate: " << getBlockName(Succ)
                         << ", probability: " << DupProb
                         << " (Tail Duplicate)\n");
       BestSucc.BB = Succ;
@@ -1553,7 +1583,7 @@
   }
 
   if (BestSucc.BB)
-    LLVM_DEBUG(dbgs() << "    Selected: " << getBlockName(BestSucc.BB) << "\n");
+    LLVM_DEBUG2(dbgs() << "    Selected: " << getBlockName(BestSucc.BB) << "\n");
 
   return BestSucc;
 }
@@ -1599,7 +1629,7 @@
            "Found CFG-violating block");
 
     BlockFrequency CandidateFreq = MBFI->getBlockFreq(MBB);
-    LLVM_DEBUG(dbgs() << "    " << getBlockName(MBB) << " -> ";
+    LLVM_DEBUG2(dbgs() << "    " << getBlockName(MBB) << " -> ";
                MBFI->printBlockFreq(dbgs(), CandidateFreq) << " (freq)\n");
 
     // For ehpad, we layout the least probable first as to avoid jumping back
@@ -1711,6 +1741,7 @@
     MachineBasicBlock* BestSucc = Result.BB;
     bool ShouldTailDup = Result.ShouldTailDup;
     if (allowTailDupPlacement())
+      dbgs() << "chris: shouldTailDuplicate point5\n";
       ShouldTailDup |= (BestSucc && shouldTailDuplicate(BestSucc));
 
     // If an immediate successor isn't available, look for the best viable
@@ -1726,7 +1757,7 @@
       if (!BestSucc)
         break;
 
-      LLVM_DEBUG(dbgs() << "Unnatural loop CFG detected, forcibly merging the "
+      LLVM_DEBUG2(dbgs() << "Unnatural loop CFG detected, forcibly merging the "
                            "layout successor until the CFG reduces\n");
     }
 
@@ -1746,14 +1777,14 @@
     // Zero out UnscheduledPredecessors for the successor we're about to merge in case
     // we selected a successor that didn't fit naturally into the CFG.
     SuccChain.UnscheduledPredecessors = 0;
-    LLVM_DEBUG(dbgs() << "Merging from " << getBlockName(BB) << " to "
+    LLVM_DEBUG2(dbgs() << "Merging from " << getBlockName(BB) << " to "
                       << getBlockName(BestSucc) << "\n");
     markChainSuccessors(SuccChain, LoopHeaderBB, BlockFilter);
     Chain.merge(BestSucc, &SuccChain);
     BB = *std::prev(Chain.end());
   }
 
-  LLVM_DEBUG(dbgs() << "Finished forming chain for header block "
+  LLVM_DEBUG2(dbgs() << "Finished forming chain for header block "
                     << getBlockName(*Chain.begin()) << "\n");
 }
 
@@ -1810,6 +1841,8 @@
   // i.e. when the layout predecessor does not fallthrough to the loop header.
   // In practice this never happens though: there always seems to be a preheader
   // that can fallthrough and that is also placed before the header.
+  LLVM_DEBUG2(dbgs() << "chris: hasOptSize: "
+                    << F->getFunction().hasOptSize() << "\n");
   if (F->getFunction().hasOptSize())
     return L.getHeader();
 
@@ -1817,18 +1850,30 @@
   // crazy branches. If it has, we need to start with the header at the top to
   // prevent pulling the preheader into the loop body.
   BlockChain &HeaderChain = *BlockToChain[L.getHeader()];
+  LLVM_DEBUG2(dbgs() << "chris: count: "
+                    << LoopBlockSet.count(*HeaderChain.begin()) << "\n");
   if (!LoopBlockSet.count(*HeaderChain.begin()))
     return L.getHeader();
 
-  LLVM_DEBUG(dbgs() << "Finding best loop top for: "
+  LLVM_DEBUG2(dbgs() << "Finding best loop top for: "
                     << getBlockName(L.getHeader()) << "\n");
 
   BlockFrequency BestPredFreq;
   MachineBasicBlock *BestPred = nullptr;
   for (MachineBasicBlock *Pred : L.getHeader()->predecessors()) {
+      LLVM_DEBUG2(dbgs() << "chris loop: predecessors: " << getBlockName(Pred) << ", has "
+                      << Pred->succ_size() << " successors\n ");
+  }
+  for (MachineBasicBlock *Pred : L.getHeader()->predecessors()) {
+      LLVM_DEBUG2(dbgs() << "chris: continue header pred: " << getBlockName(Pred) << ", has "
+                      << Pred->succ_size() << " successors, ";
+               MBFI->printBlockFreq(dbgs(), Pred) << " freq\n");
+     dbgs() << "chris: count=" << LoopBlockSet.count(Pred) << "\n";
     if (!LoopBlockSet.count(Pred))
+    {
       continue;
-    LLVM_DEBUG(dbgs() << "    header pred: " << getBlockName(Pred) << ", has "
+    }
+    LLVM_DEBUG2(dbgs() << "    header pred: " << getBlockName(Pred) << ", has "
                       << Pred->succ_size() << " successors, ";
                MBFI->printBlockFreq(dbgs(), Pred) << " freq\n");
     if (Pred->succ_size() > 1)
@@ -1848,7 +1893,7 @@
 
   // If no direct predecessor is fine, just use the loop header.
   if (!BestPred) {
-    LLVM_DEBUG(dbgs() << "    final top unchanged\n");
+    LLVM_DEBUG2(dbgs() << "    final top unchanged\n");
     return L.getHeader();
   }
 
@@ -1858,7 +1903,7 @@
          *BestPred->pred_begin() != L.getHeader())
     BestPred = *BestPred->pred_begin();
 
-  LLVM_DEBUG(dbgs() << "    final top: " << getBlockName(BestPred) << "\n");
+  LLVM_DEBUG2(dbgs() << "    final top: " << getBlockName(BestPred) << "\n");
   return BestPred;
 }
 
@@ -1890,9 +1935,12 @@
   // blocks where rotating to exit with that block will reach an outer loop.
   SmallPtrSet<MachineBasicBlock *, 4> BlocksExitingToOuterLoop;
 
-  LLVM_DEBUG(dbgs() << "Finding best loop exit for: "
+  LLVM_DEBUG2(dbgs() << "Finding best loop exit for: "
                     << getBlockName(L.getHeader()) << "\n");
   for (MachineBasicBlock *MBB : L.getBlocks()) {
+        LLVM_DEBUG2(dbgs() << "chris: MBB   : " << getBlockName(MBB) << "\n");
+  }
+  for (MachineBasicBlock *MBB : L.getBlocks()) {
     BlockChain &Chain = *BlockToChain[MBB];
     // Ensure that this block is at the end of a chain; otherwise it could be
     // mid-way through an inner loop or a successor of an unanalyzable branch.
@@ -1914,14 +1962,14 @@
       BlockChain &SuccChain = *BlockToChain[Succ];
       // Don't split chains, either this chain or the successor's chain.
       if (&Chain == &SuccChain) {
-        LLVM_DEBUG(dbgs() << "    exiting: " << getBlockName(MBB) << " -> "
+        LLVM_DEBUG2(dbgs() << "    exiting: " << getBlockName(MBB) << " -> "
                           << getBlockName(Succ) << " (chain conflict)\n");
         continue;
       }
 
       auto SuccProb = MBPI->getEdgeProbability(MBB, Succ);
       if (LoopBlockSet.count(Succ)) {
-        LLVM_DEBUG(dbgs() << "    looping: " << getBlockName(MBB) << " -> "
+        LLVM_DEBUG2(dbgs() << "    looping: " << getBlockName(MBB) << " -> "
                           << getBlockName(Succ) << " (" << SuccProb << ")\n");
         HasLoopingSucc = true;
         continue;
@@ -1935,7 +1983,7 @@
       }
 
       BlockFrequency ExitEdgeFreq = MBFI->getBlockFreq(MBB) * SuccProb;
-      LLVM_DEBUG(dbgs() << "    exiting: " << getBlockName(MBB) << " -> "
+      LLVM_DEBUG2(dbgs() << "    exiting: " << getBlockName(MBB) << " -> "
                         << getBlockName(Succ) << " [L:" << SuccLoopDepth
                         << "] (";
                  MBFI->printBlockFreq(dbgs(), ExitEdgeFreq) << ")\n");
@@ -1962,12 +2010,12 @@
   // Without a candidate exiting block or with only a single block in the
   // loop, just use the loop header to layout the loop.
   if (!ExitingBB) {
-    LLVM_DEBUG(
+    LLVM_DEBUG2(
         dbgs() << "    No other candidate exit blocks, using loop header\n");
     return nullptr;
   }
   if (L.getNumBlocks() == 1) {
-    LLVM_DEBUG(dbgs() << "    Loop has 1 block, using loop header as exit\n");
+    LLVM_DEBUG2(dbgs() << "    Loop has 1 block, using loop header as exit\n");
     return nullptr;
   }
 
@@ -1978,7 +2026,7 @@
       !BlocksExitingToOuterLoop.count(ExitingBB))
     return nullptr;
 
-  LLVM_DEBUG(dbgs() << "  Best exiting block: " << getBlockName(ExitingBB)
+  LLVM_DEBUG2(dbgs() << "  Best exiting block: " << getBlockName(ExitingBB)
                     << "\n");
   return ExitingBB;
 }
@@ -2081,7 +2129,7 @@
         return;
   }
 
-  LLVM_DEBUG(dbgs() << "Rotating loop to put exit " << getBlockName(ExitingBB)
+  LLVM_DEBUG2(dbgs() << "Rotating loop to put exit " << getBlockName(ExitingBB)
                     << " at bottom\n");
   std::rotate(LoopChain.begin(), std::next(ExitIt), LoopChain.end());
 }
@@ -2217,7 +2265,7 @@
       }
     }
 
-    LLVM_DEBUG(dbgs() << "The cost of loop rotation by making "
+    LLVM_DEBUG2(dbgs() << "The cost of loop rotation by making "
                       << getBlockName(*Iter)
                       << " to the top: " << Cost.getFrequency() << "\n");
 
@@ -2228,7 +2276,7 @@
   }
 
   if (RotationPos != LoopChain.end()) {
-    LLVM_DEBUG(dbgs() << "Rotate loop by making " << getBlockName(*RotationPos)
+    LLVM_DEBUG2(dbgs() << "Rotate loop by making " << getBlockName(*RotationPos)
                       << " to the top\n");
     std::rotate(LoopChain.begin(), RotationPos, LoopChain.end());
   }
@@ -2279,8 +2327,17 @@
 void MachineBlockPlacement::buildLoopChains(const MachineLoop &L) {
   // First recurse through any nested loops, building chains for those inner
   // loops.
+  LLVM_DEBUG2(dbgs() << "chris: buildLoopChains: "
+                    << getBlockName(L.getHeader()) << "\n");
   for (const MachineLoop *InnerLoop : L)
+  {
+    LLVM_DEBUG2(dbgs() << "chris: InnerLoop: "
+                    << getBlockName(InnerLoop->getHeader()) << "\n");
+  }
+  for (const MachineLoop *InnerLoop : L)
+  {
     buildLoopChains(*InnerLoop);
+  }
 
   assert(BlockWorkList.empty() &&
          "BlockWorkList not empty when starting to build loop chains.");
@@ -2300,6 +2357,7 @@
   // predecessors to the header if there is one which will result in strictly
   // fewer branches in the loop body.
   // When we use profile data to rotate the loop, this is unnecessary.
+  dbgs() << "chris:RotateLoopWithProfile=" << RotateLoopWithProfile << "\n";
   MachineBasicBlock *LoopTop =
       RotateLoopWithProfile ? L.getHeader() : findBestLoopTop(L, LoopBlockSet);
 
@@ -2333,7 +2391,7 @@
   else
     rotateLoop(LoopChain, PreferredLoopExit, LoopBlockSet);
 
-  LLVM_DEBUG({
+  LLVM_DEBUG2({
     // Crash at the end so we get all of the debugging output first.
     bool BadLoop = false;
     if (LoopChain.UnscheduledPredecessors) {
@@ -2392,7 +2450,7 @@
       // Ensure that the layout successor is a viable block, as we know that
       // fallthrough is a possibility.
       assert(NextFI != FE && "Can't fallthrough past the last block.");
-      LLVM_DEBUG(dbgs() << "Pre-merging due to unanalyzable fallthrough: "
+      LLVM_DEBUG2(dbgs() << "Pre-merging due to unanalyzable fallthrough: "
                         << getBlockName(BB) << " -> " << getBlockName(NextBB)
                         << "\n");
       Chain->merge(NextBB, nullptr);
@@ -2407,7 +2465,14 @@
   // Build any loop-based chains.
   PreferredLoopExit = nullptr;
   for (MachineLoop *L : *MLI)
+  {
+    LLVM_DEBUG2(dbgs() << "chris: L: "
+                    << getBlockName(L->getHeader()) << "\n");
+  }
+  for (MachineLoop *L : *MLI)
+  {
     buildLoopChains(*L);
+  }
 
   assert(BlockWorkList.empty() &&
          "BlockWorkList should be empty before building final chain.");
@@ -2424,7 +2489,7 @@
 #ifndef NDEBUG
   using FunctionBlockSetType = SmallPtrSet<MachineBasicBlock *, 16>;
 #endif
-  LLVM_DEBUG({
+  LLVM_DEBUG2({
     // Crash at the end so we get all of the debugging output first.
     bool BadFunc = false;
     FunctionBlockSetType FunctionBlockSet;
@@ -2449,9 +2514,9 @@
 
   // Splice the blocks into place.
   MachineFunction::iterator InsertPos = F->begin();
-  LLVM_DEBUG(dbgs() << "[MBP] Function: " << F->getName() << "\n");
+  LLVM_DEBUG2(dbgs() << "[MBP] Function: " << F->getName() << "\n");
   for (MachineBasicBlock *ChainBB : FunctionChain) {
-    LLVM_DEBUG(dbgs() << (ChainBB == *FunctionChain.begin() ? "Placing chain "
+    LLVM_DEBUG2(dbgs() << (ChainBB == *FunctionChain.begin() ? "Placing chain "
                                                             : "          ... ")
                       << getBlockName(ChainBB) << "\n");
     if (InsertPos != MachineFunction::iterator(ChainBB))
@@ -2538,9 +2603,9 @@
           MBPI->getEdgeProbability(ChainBB, FBB) >
               MBPI->getEdgeProbability(ChainBB, TBB) &&
           !TII->reverseBranchCondition(Cond)) {
-        LLVM_DEBUG(dbgs() << "Reverse order of the two branches: "
+        LLVM_DEBUG2(dbgs() << "Reverse order of the two branches: "
                           << getBlockName(ChainBB) << "\n");
-        LLVM_DEBUG(dbgs() << "    Edge probability: "
+        LLVM_DEBUG2(dbgs() << "    Edge probability: "
                           << MBPI->getEdgeProbability(ChainBB, FBB) << " vs "
                           << MBPI->getEdgeProbability(ChainBB, TBB) << "\n");
         DebugLoc dl; // FIXME: this is nowhere
@@ -2704,10 +2769,11 @@
     MachineFunction::iterator &PrevUnplacedBlockIt,
     bool &DuplicatedToLPred) {
   DuplicatedToLPred = false;
+  dbgs() << "chris: shouldTailDuplicate point6\n";
   if (!shouldTailDuplicate(BB))
     return false;
 
-  LLVM_DEBUG(dbgs() << "Redoing tail duplication for Succ#" << BB->getNumber()
+  LLVM_DEBUG2(dbgs() << "Redoing tail duplication for Succ#" << BB->getNumber()
                     << "\n");
 
   // This has to be a callback because none of it can be done after
@@ -2756,7 +2822,7 @@
         if (RemBB == PreferredLoopExit)
           PreferredLoopExit = nullptr;
 
-        LLVM_DEBUG(dbgs() << "TailDuplicator deleted block: "
+        LLVM_DEBUG2(dbgs() << "TailDuplicator deleted block: "
                           << getBlockName(RemBB) << "\n");
       };
   auto RemovalCallbackRef =
@@ -2790,7 +2856,21 @@
 
 bool MachineBlockPlacement::runOnMachineFunction(MachineFunction &MF) {
   if (skipFunction(MF.getFunction()))
+  {
+    dbgs() << "chris: skip MachineBlockPlacement::runOnMachineFunction\n";
     return false;
+  }
+  dbgs() << "chris: MachineBlockPlacement::runOnMachineFunction\n";
+
+  for (MachineBasicBlock &BB : MF) {
+    dbgs() << "BB: " << getBlockName(&BB) << "   size: " << BB.succ_size() << "\n";
+    for (MachineBasicBlock *Succ : BB.successors()) {
+      dbgs() << "  Succ: " << getBlockName(Succ) << "   size: " << Succ->succ_size() << "\n";
+    }
+    for (MachineBasicBlock *PreSucc : BB.predecessors()) {
+      dbgs() << "  PreSucc: " << getBlockName(PreSucc) << "   size: " << PreSucc->succ_size() << "\n";
+    }
+  }
 
   // Check for single-block functions and skip them.
   if (std::next(MF.begin()) == MF.end())
@@ -2951,6 +3031,7 @@
   if (std::next(F.begin()) == F.end())
     return false;
 
+  dbgs() <<"chris: MachineBlockPlacementStats::runOnMachineFunction\n";
   MBPI = &getAnalysis<MachineBranchProbabilityInfo>();
   MBFI = &getAnalysis<MachineBlockFrequencyInfo>();
 
@@ -2970,6 +3051,10 @@
       ++NumBranches;
       BranchTakenFreq += EdgeFreq.getFrequency();
     }
+    dbgs() << "NumCondBranches=" << NumCondBranches << "/n";
+    dbgs() << "NumUncondBranches =" << NumUncondBranches<< "/n";
+    dbgs() << "NumCondBranches=" << CondBranchTakenFreq << "/n";
+    dbgs() << "NumUncondBranches =" << UncondBranchTakenFreq<< "/n";
   }
 
   return false;
diff -uNar CodeGen.old/TailDuplication.cpp CodeGen.new/TailDuplication.cpp
--- CodeGen.old/TailDuplication.cpp	2019-08-20 18:14:10.911267093 +0800
+++ CodeGen.new/TailDuplication.cpp	2019-08-20 18:13:18.151266102 +0800
@@ -61,6 +61,16 @@
 
 char TailDuplicate::ID;
 char EarlyTailDuplicate::ID;
+static std::string getBlockName(const MachineBasicBlock *BB) {
+  std::string Result;
+  raw_string_ostream OS(Result);
+  OS << printMBBReference(*BB);
+  OS << " ('" << BB->getName() << "')";
+  OS << " ('" << BB->getFullName().c_str() << "')";
+  OS << " ('" << BB->getNumber() << "')";
+  OS.flush();
+  return Result;
+}
 
 char &llvm::TailDuplicateID = TailDuplicate::ID;
 char &llvm::EarlyTailDuplicateID = EarlyTailDuplicate::ID;
@@ -73,6 +83,15 @@
   if (skipFunction(MF.getFunction()))
     return false;
 
+  for (MachineBasicBlock &BB : MF) {
+    dbgs() << "BB: " << getBlockName(&BB) << "   size: " << BB.succ_size() << "\n";
+    for (MachineBasicBlock *Succ : BB.successors()) {
+      dbgs() << "  Succ: " << getBlockName(Succ) << "   size: " << Succ->succ_size() << "\n";
+    }
+    for (MachineBasicBlock *PreSucc : BB.predecessors()) {
+      dbgs() << "  PreSucc: " << getBlockName(PreSucc) << "   size: " << PreSucc->succ_size() << "\n";
+    }
+  }
   auto MBPI = &getAnalysis<MachineBranchProbabilityInfo>();
   Duplicator.initMF(MF, PreRegAlloc, MBPI, /*LayoutMode=*/false);
 
diff -uNar CodeGen.old/TailDuplicator.cpp CodeGen.new/TailDuplicator.cpp
--- CodeGen.old/TailDuplicator.cpp	2019-08-20 18:14:10.911267093 +0800
+++ CodeGen.new/TailDuplicator.cpp	2019-08-20 18:13:18.151266102 +0800
@@ -45,6 +45,7 @@
 using namespace llvm;
 
 #define DEBUG_TYPE "tailduplication"
+#define LLVM_DEBUG2(X) do { X; } while (false)
 
 STATISTIC(NumTails, "Number of tails duplicated");
 STATISTIC(NumTailDups, "Number of tail duplicated blocks");
@@ -261,7 +262,7 @@
   bool MadeChange = false;
 
   if (PreRegAlloc && TailDupVerify) {
-    LLVM_DEBUG(dbgs() << "\n*** Before tail-duplicating\n");
+    LLVM_DEBUG2(dbgs() << "\n*** Before tail-duplicating\n");
     VerifyPHIs(*MF, true);
   }
 
@@ -717,7 +718,7 @@
       continue;
 
     Changed = true;
-    LLVM_DEBUG(dbgs() << "\nTail-duplicating into PredBB: " << *PredBB
+    LLVM_DEBUG2(dbgs() << "\nTail-duplicating into PredBB: " << *PredBB
                       << "From simple Succ: " << *TailBB);
 
     MachineBasicBlock *NewTarget = *TailBB->succ_begin();
@@ -798,7 +799,7 @@
                                    MachineBasicBlock *ForcedLayoutPred,
                                    SmallVectorImpl<MachineBasicBlock *> &TDBBs,
                                    SmallVectorImpl<MachineInstr *> &Copies) {
-  LLVM_DEBUG(dbgs() << "\n*** Tail-duplicating " << printMBBReference(*TailBB)
+  LLVM_DEBUG2(dbgs() << "\n*** Tail-duplicating " << printMBBReference(*TailBB)
                     << '\n');
 
   DenseSet<unsigned> UsedByPhi;
@@ -829,7 +830,7 @@
     if (IsLayoutSuccessor)
       continue;
 
-    LLVM_DEBUG(dbgs() << "\nTail-duplicating into PredBB: " << *PredBB
+    LLVM_DEBUG2(dbgs() << "\nTail-duplicating into PredBB: " << *PredBB
                       << "From Succ: " << *TailBB);
 
     TDBBs.push_back(PredBB);
@@ -892,7 +893,7 @@
       (!PriorTBB || PriorTBB == TailBB) &&
       TailBB->pred_size() == 1 &&
       !TailBB->hasAddressTaken()) {
-    LLVM_DEBUG(dbgs() << "\nMerging into block: " << *PrevBB
+    LLVM_DEBUG2(dbgs() << "\nMerging into block: " << *PrevBB
                       << "From MBB: " << *TailBB);
     // There may be a branch to the layout successor. This is unlikely but it
     // happens. The correct thing to do is to remove the branch before
@@ -998,7 +999,7 @@
     MachineBasicBlock *MBB,
     function_ref<void(MachineBasicBlock *)> *RemovalCallback) {
   assert(MBB->pred_empty() && "MBB must be dead!");
-  LLVM_DEBUG(dbgs() << "\nRemoving MBB: " << *MBB);
+  LLVM_DEBUG2(dbgs() << "\nRemoving MBB: " << *MBB);
 
   if (RemovalCallback)
     (*RemovalCallback)(MBB);
