BISECT: running pass (1) Simplify the CFG on function (test_guard_adjacent_same_cond)
BISECT: running pass (2) SROA on function (test_guard_adjacent_same_cond)
BISECT: running pass (3) Early CSE on function (test_guard_adjacent_same_cond)
BISECT: running pass (4) Simplify the CFG on function (test_guard_adjacent_diff_cond)
BISECT: running pass (5) SROA on function (test_guard_adjacent_diff_cond)
BISECT: running pass (6) Early CSE on function (test_guard_adjacent_diff_cond)
BISECT: running pass (7) Simplify the CFG on function (test_guard_adjacent_diff_cond2)
BISECT: running pass (8) SROA on function (test_guard_adjacent_diff_cond2)
BISECT: running pass (9) Early CSE on function (test_guard_adjacent_diff_cond2)
BISECT: running pass (10) Simplify the CFG on function (negative_load)
BISECT: running pass (11) SROA on function (negative_load)
BISECT: running pass (12) Early CSE on function (negative_load)
BISECT: running pass (13) Simplify the CFG on function (deref_load)
BISECT: running pass (14) SROA on function (deref_load)
BISECT: running pass (15) Early CSE on function (deref_load)
BISECT: running pass (16) Simplify the CFG on function (negative_div)
BISECT: running pass (17) SROA on function (negative_div)
BISECT: running pass (18) Early CSE on function (negative_div)
BISECT: running pass (19) Simplify the CFG on function (negative_window)
BISECT: running pass (20) SROA on function (negative_window)
BISECT: running pass (21) Early CSE on function (negative_window)
CheckModuleDebugify [Force set function attributes]: PASS
BISECT: running pass (22) Infer set function attributes on module (call-guard.ll)
CheckModuleDebugify [Infer set function attributes]: PASS
BISECT: running pass (23) Interprocedural Sparse Conditional Constant Propagation on module (call-guard.ll)
CheckModuleDebugify [Interprocedural Sparse Conditional Constant Propagation]: PASS
BISECT: running pass (24) Called Value Propagation on module (call-guard.ll)
CheckModuleDebugify [Called Value Propagation]: PASS
BISECT: running pass (25) Deduce and propagate attributes on module (call-guard.ll)
CheckModuleDebugify [Deduce and propagate attributes]: PASS
BISECT: running pass (26) Global Variable Optimizer on module (call-guard.ll)
CheckModuleDebugify [Global Variable Optimizer]: PASS
BISECT: running pass (27) Promote Memory to Register on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Promote Memory to Register]: PASS
BISECT: running pass (28) Promote Memory to Register on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Promote Memory to Register]: PASS
BISECT: running pass (29) Promote Memory to Register on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Promote Memory to Register]: PASS
BISECT: running pass (30) Promote Memory to Register on function (negative_load)
CheckFunctionDebugify [Promote Memory to Register]: PASS
BISECT: running pass (31) Promote Memory to Register on function (deref_load)
CheckFunctionDebugify [Promote Memory to Register]: PASS
BISECT: running pass (32) Promote Memory to Register on function (negative_div)
CheckFunctionDebugify [Promote Memory to Register]: PASS
BISECT: running pass (33) Promote Memory to Register on function (negative_window)
CheckFunctionDebugify [Promote Memory to Register]: PASS
BISECT: running pass (34) Dead Argument Elimination on module (call-guard.ll)
CheckModuleDebugify [Dead Argument Elimination]: PASS
BISECT: running pass (35) Combine redundant instructions on function (test_guard_adjacent_same_cond)
chris-InstructionCombiningPass::runOnFunction
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !13
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !14
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !15
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !16
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !17
runOnFunction: I:  ret void, !dbg !18
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !13
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !14
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !15
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !16
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !17
INSTCOMBINE ITERATION: Inst(start):  ret void, !dbg !18


INSTCOMBINE ITERATION #1 on test_guard_adjacent_same_cond
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !13
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !14
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !15
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !16
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !17
INSTCOMBINE ITERATION: Inst(end):  ret void, !dbg !18
chris-worklist-bb: bb: 
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !13
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !14
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !15
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !16
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !17
  ret void, !dbg !18

chris-worklist-bb: BB: 
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !13
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !14
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !15
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !16
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !17
  ret void, !dbg !18

chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !13
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !14
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !15
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !16
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !17
chris-worklist-bb: BB end:   ret void, !dbg !18
IC: ADDING: 11 instrs to worklist
chris-AddInitialGroup: I:   ret void, !dbg !18
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !17
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !16
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !15
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !14
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !13
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
 ok, break
Inst[end]:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
IC: ERASE   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
visit: nullptr 
test3
RemoveOne!!!
run: WorkList: null
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
 ok, break
Inst[end]:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
IC: ERASE   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
visit: nullptr 
test3
RemoveOne!!!
run: WorkList: null
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
 ok, break
Inst[end]:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
IC: ERASE   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
visit: nullptr 
test3
RemoveOne!!!
run: WorkList: null
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
 ok, break
Inst[end]:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
IC: ERASE   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
visit: nullptr 
test3
RemoveOne!!!
run: WorkList: null
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !13
 ok, break
Inst[end]:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !13
IC: ERASE   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !13
visit: nullptr 
test3
RemoveOne!!!
run: WorkList: null
RemoveOne!!!
chris-RemoveOne:   ret void, !dbg !13
chris-RemoveOne: return I  ret void, !dbg !13
run: WorkList:   ret void, !dbg !13
chris-run: I=  ret void, !dbg !13
chris-run: I-end=  ret void, !dbg !13
IC: Visiting:   ret void, !dbg !13
test1: I=  ret void, !dbg !13
visit: nullptr 
test3
test4


INSTCOMBINE ITERATION #2 on test_guard_adjacent_same_cond
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
INSTCOMBINE ITERATION: Inst(end):  ret void, !dbg !13
chris-worklist-bb: bb: 
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
  ret void, !dbg !13

chris-worklist-bb: BB: 
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
  ret void, !dbg !13

chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
chris-worklist-bb: BB end:   ret void, !dbg !13
IC: ADDING: 6 instrs to worklist
chris-AddInitialGroup: I:   ret void, !dbg !13
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !12
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !11
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
 ok, break
Inst[end]:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
IC: ERASE   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
visit: nullptr 
test3
RemoveOne!!!
run: WorkList: null
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
 ok, break
Inst[end]:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
IC: ERASE   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
visit: nullptr 
test3
RemoveOne!!!
run: WorkList: null
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  ret void, !dbg !11
 ok, break
Inst[end]:   ret void, !dbg !11
chris-debug7-8
chris-debug4
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   ret void, !dbg !11
chris-RemoveOne: return I  ret void, !dbg !11
run: WorkList:   ret void, !dbg !11
chris-run: I=  ret void, !dbg !11
chris-run: I-end=  ret void, !dbg !11
IC: Visiting:   ret void, !dbg !11
test1: I=  ret void, !dbg !11
visit: nullptr 
test3
test4


INSTCOMBINE ITERATION #3 on test_guard_adjacent_same_cond
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
INSTCOMBINE ITERATION: Inst(end):  ret void, !dbg !11
chris-worklist-bb: bb: 
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
  ret void, !dbg !11

chris-worklist-bb: BB: 
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
  ret void, !dbg !11

chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-worklist-bb: BB end:   ret void, !dbg !11
IC: ADDING: 4 instrs to worklist
chris-AddInitialGroup: I:   ret void, !dbg !11
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !10
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
 ok, break
Inst[end]:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
IC: ERASE   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
visit: nullptr 
test3
RemoveOne!!!
run: WorkList: null
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  ret void, !dbg !10
 ok, break
Inst[end]:   ret void, !dbg !10
chris-debug7-8
chris-debug4
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   ret void, !dbg !10
chris-RemoveOne: return I  ret void, !dbg !10
run: WorkList:   ret void, !dbg !10
chris-run: I=  ret void, !dbg !10
chris-run: I-end=  ret void, !dbg !10
IC: Visiting:   ret void, !dbg !10
test1: I=  ret void, !dbg !10
visit: nullptr 
test3
test4


INSTCOMBINE ITERATION #4 on test_guard_adjacent_same_cond
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
INSTCOMBINE ITERATION: Inst(end):  ret void, !dbg !10
chris-worklist-bb: bb: 
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
  ret void, !dbg !10

chris-worklist-bb: BB: 
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
  ret void, !dbg !10

chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-worklist-bb: BB end:   ret void, !dbg !10
IC: ADDING: 3 instrs to worklist
chris-AddInitialGroup: I:   ret void, !dbg !10
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
 ok, break
Inst[end]:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
IC: ERASE   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !9
visit: nullptr 
test3
RemoveOne!!!
run: WorkList: null
RemoveOne!!!
chris-RemoveOne:   ret void, !dbg !9
chris-RemoveOne: return I  ret void, !dbg !9
run: WorkList:   ret void, !dbg !9
chris-run: I=  ret void, !dbg !9
chris-run: I-end=  ret void, !dbg !9
IC: Visiting:   ret void, !dbg !9
test1: I=  ret void, !dbg !9
visit: nullptr 
test3
test4


INSTCOMBINE ITERATION #5 on test_guard_adjacent_same_cond
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
INSTCOMBINE ITERATION: Inst(end):  ret void, !dbg !9
chris-worklist-bb: bb: 
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  ret void, !dbg !9

chris-worklist-bb: BB: 
  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  ret void, !dbg !9

chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-worklist-bb: BB end:   ret void, !dbg !9
IC: ADDING: 2 instrs to worklist
chris-AddInitialGroup: I:   ret void, !dbg !9
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A) [ "deopt"() ], !dbg !8
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  ret void, !dbg !9
 ok, break
Inst[end]:   ret void, !dbg !9
chris-debug7-8
chris-debug4
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   ret void, !dbg !9
chris-RemoveOne: return I  ret void, !dbg !9
run: WorkList:   ret void, !dbg !9
chris-run: I=  ret void, !dbg !9
chris-run: I-end=  ret void, !dbg !9
IC: Visiting:   ret void, !dbg !9
test1: I=  ret void, !dbg !9
visit: nullptr 
test3
test4
WARNING: Missing line 2
WARNING: Missing line 3
WARNING: Missing line 4
WARNING: Missing line 5
WARNING: Missing line 6
WARNING: Missing line 7
WARNING: Missing line 8
WARNING: Missing line 9
WARNING: Missing line 10
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: running pass (36) Simplify the CFG on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: running pass (37) Combine redundant instructions on function (test_guard_adjacent_diff_cond)
chris-InstructionCombiningPass::runOnFunction
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !9
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !10
runOnFunction: I:  ret void, !dbg !11
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !9
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !10
INSTCOMBINE ITERATION: Inst(start):  ret void, !dbg !11


INSTCOMBINE ITERATION #1 on test_guard_adjacent_diff_cond
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !9
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !10
INSTCOMBINE ITERATION: Inst(end):  ret void, !dbg !11
chris-worklist-bb: bb: 
  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !9
  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !10
  ret void, !dbg !11

chris-worklist-bb: BB: 
  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !9
  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !10
  ret void, !dbg !11

chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !9
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !10
chris-worklist-bb: BB end:   ret void, !dbg !11
IC: ADDING: 4 instrs to worklist
chris-AddInitialGroup: I:   ret void, !dbg !11
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !10
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !9
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !8
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !9
 ok, break
Inst[end]:   call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !9
MoveI:   call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !9
chris add g: I:  %1 = and i1 %A, %B
IC: ADD:   %1 = and i1 %A, %B
IC: ERASE   call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !9
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %1 = and i1 %A, %B, !dbg !8
chris-RemoveOne: return I  %1 = and i1 %A, %B, !dbg !8
run: WorkList:   %1 = and i1 %A, %B, !dbg !8
chris-run: I=  %1 = and i1 %A, %B, !dbg !8
chris-run: I-end=  %1 = and i1 %A, %B, !dbg !8
IC: Visiting:   %1 = and i1 %A, %B, !dbg !8
test1: I=  %1 = and i1 %A, %B, !dbg !8
visit: nullptr 
test3
RemoveOne!!!
run: WorkList: null
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  ret void, !dbg !10
 ok, break
Inst[end]:   ret void, !dbg !10
chris-debug7-8
chris-debug4
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   ret void, !dbg !10
chris-RemoveOne: return I  ret void, !dbg !10
run: WorkList:   ret void, !dbg !10
chris-run: I=  ret void, !dbg !10
chris-run: I-end=  ret void, !dbg !10
IC: Visiting:   ret void, !dbg !10
test1: I=  ret void, !dbg !10
visit: nullptr 
test3
test4


INSTCOMBINE ITERATION #2 on test_guard_adjacent_diff_cond
INSTCOMBINE ITERATION: Inst(end):  %1 = and i1 %A, %B, !dbg !8
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %1, i32 123) [ "deopt"() ], !dbg !8
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
INSTCOMBINE ITERATION: Inst(end):  ret void, !dbg !10
chris-worklist-bb: bb: 
  %1 = and i1 %A, %B, !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %1, i32 123) [ "deopt"() ], !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
  ret void, !dbg !10

chris-worklist-bb: BB: 
  %1 = and i1 %A, %B, !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %1, i32 123) [ "deopt"() ], !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
  ret void, !dbg !10

chris-worklist-bb: BB end:   %1 = and i1 %A, %B, !dbg !8
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %1, i32 123) [ "deopt"() ], !dbg !8
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
chris-worklist-bb: BB end:   ret void, !dbg !10
IC: ADDING: 4 instrs to worklist
chris-AddInitialGroup: I:   ret void, !dbg !10
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %1, i32 123) [ "deopt"() ], !dbg !8
chris-AddInitialGroup: I:   %1 = and i1 %A, %B, !dbg !8
RemoveOne!!!
chris-RemoveOne:   %1 = and i1 %A, %B, !dbg !8
chris-RemoveOne: return I  %1 = and i1 %A, %B, !dbg !8
run: WorkList:   %1 = and i1 %A, %B, !dbg !8
chris-run: I=  %1 = and i1 %A, %B, !dbg !8
chris-run: I-end=  %1 = and i1 %A, %B, !dbg !8
IC: Visiting:   %1 = and i1 %A, %B, !dbg !8
test1: I=  %1 = and i1 %A, %B, !dbg !8
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %1, i32 123) [ "deopt"() ], !dbg !8
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %1, i32 123) [ "deopt"() ], !dbg !8
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %1, i32 123) [ "deopt"() ], !dbg !8
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %1, i32 123) [ "deopt"() ], !dbg !8
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %1, i32 123) [ "deopt"() ], !dbg !8
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %1, i32 123) [ "deopt"() ], !dbg !8
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %1, i32 123) [ "deopt"() ], !dbg !8
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %1, i32 123) [ "deopt"() ], !dbg !8
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
 ok, break
Inst[end]:   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
MoveI:   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
chris add g: I:  %2 = and i1 %1, %C
IC: ADD:   %2 = and i1 %1, %C
IC: ERASE   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !9
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %2 = and i1 %1, %C, !dbg !8
chris-RemoveOne: return I  %2 = and i1 %1, %C, !dbg !8
run: WorkList:   %2 = and i1 %1, %C, !dbg !8
chris-run: I=  %2 = and i1 %1, %C, !dbg !8
chris-run: I-end=  %2 = and i1 %1, %C, !dbg !8
IC: Visiting:   %2 = and i1 %1, %C, !dbg !8
test1: I=  %2 = and i1 %1, %C, !dbg !8
visit: nullptr 
test3
RemoveOne!!!
run: WorkList: null
RemoveOne!!!
chris-RemoveOne:   ret void, !dbg !9
chris-RemoveOne: return I  ret void, !dbg !9
run: WorkList:   ret void, !dbg !9
chris-run: I=  ret void, !dbg !9
chris-run: I-end=  ret void, !dbg !9
IC: Visiting:   ret void, !dbg !9
test1: I=  ret void, !dbg !9
visit: nullptr 
test3
test4


INSTCOMBINE ITERATION #3 on test_guard_adjacent_diff_cond
INSTCOMBINE ITERATION: Inst(end):  %1 = and i1 %A, %B, !dbg !8
INSTCOMBINE ITERATION: Inst(end):  %2 = and i1 %1, %C, !dbg !8
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %2, i32 123) [ "deopt"() ], !dbg !8
INSTCOMBINE ITERATION: Inst(end):  ret void, !dbg !9
chris-worklist-bb: bb: 
  %1 = and i1 %A, %B, !dbg !8
  %2 = and i1 %1, %C, !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %2, i32 123) [ "deopt"() ], !dbg !8
  ret void, !dbg !9

chris-worklist-bb: BB: 
  %1 = and i1 %A, %B, !dbg !8
  %2 = and i1 %1, %C, !dbg !8
  call void (i1, ...) @llvm.experimental.guard(i1 %2, i32 123) [ "deopt"() ], !dbg !8
  ret void, !dbg !9

chris-worklist-bb: BB end:   %1 = and i1 %A, %B, !dbg !8
chris-worklist-bb: BB end:   %2 = and i1 %1, %C, !dbg !8
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %2, i32 123) [ "deopt"() ], !dbg !8
chris-worklist-bb: BB end:   ret void, !dbg !9
IC: ADDING: 4 instrs to worklist
chris-AddInitialGroup: I:   ret void, !dbg !9
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %2, i32 123) [ "deopt"() ], !dbg !8
chris-AddInitialGroup: I:   %2 = and i1 %1, %C, !dbg !8
chris-AddInitialGroup: I:   %1 = and i1 %A, %B, !dbg !8
RemoveOne!!!
chris-RemoveOne:   %1 = and i1 %A, %B, !dbg !8
chris-RemoveOne: return I  %1 = and i1 %A, %B, !dbg !8
run: WorkList:   %1 = and i1 %A, %B, !dbg !8
chris-run: I=  %1 = and i1 %A, %B, !dbg !8
chris-run: I-end=  %1 = and i1 %A, %B, !dbg !8
IC: Visiting:   %1 = and i1 %A, %B, !dbg !8
test1: I=  %1 = and i1 %A, %B, !dbg !8
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %2 = and i1 %1, %C, !dbg !8
chris-RemoveOne: return I  %2 = and i1 %1, %C, !dbg !8
run: WorkList:   %2 = and i1 %1, %C, !dbg !8
chris-run: I=  %2 = and i1 %1, %C, !dbg !8
chris-run: I-end=  %2 = and i1 %1, %C, !dbg !8
IC: Visiting:   %2 = and i1 %1, %C, !dbg !8
test1: I=  %2 = and i1 %1, %C, !dbg !8
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %2, i32 123) [ "deopt"() ], !dbg !8
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %2, i32 123) [ "deopt"() ], !dbg !8
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %2, i32 123) [ "deopt"() ], !dbg !8
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %2, i32 123) [ "deopt"() ], !dbg !8
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %2, i32 123) [ "deopt"() ], !dbg !8
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %2, i32 123) [ "deopt"() ], !dbg !8
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %2, i32 123) [ "deopt"() ], !dbg !8
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %2, i32 123) [ "deopt"() ], !dbg !8
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  ret void, !dbg !9
 ok, break
Inst[end]:   ret void, !dbg !9
chris-debug7-8
chris-debug4
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   ret void, !dbg !9
chris-RemoveOne: return I  ret void, !dbg !9
run: WorkList:   ret void, !dbg !9
chris-run: I=  ret void, !dbg !9
chris-run: I-end=  ret void, !dbg !9
IC: Visiting:   ret void, !dbg !9
test1: I=  ret void, !dbg !9
visit: nullptr 
test3
test4
WARNING: Missing line 2
WARNING: Missing line 3
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: running pass (38) Simplify the CFG on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: running pass (39) Combine redundant instructions on function (test_guard_adjacent_diff_cond2)
chris-InstructionCombiningPass::runOnFunction
runOnFunction: I:  %A = icmp slt i32 %V1, 0, !dbg !15
runOnFunction: I:  call void @llvm.dbg.value(metadata i1 %A, metadata !9, metadata !DIExpression()), !dbg !15
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
runOnFunction: I:  %B = icmp slt i32 %V2, 0, !dbg !17
runOnFunction: I:  call void @llvm.dbg.value(metadata i1 %B, metadata !11, metadata !DIExpression()), !dbg !17
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !18
runOnFunction: I:  %and = and i32 %V1, 255, !dbg !19
runOnFunction: I:  call void @llvm.dbg.value(metadata i32 %and, metadata !12, metadata !DIExpression()), !dbg !19
runOnFunction: I:  %C = icmp sle i32 %and, 128, !dbg !20
runOnFunction: I:  call void @llvm.dbg.value(metadata i1 %C, metadata !14, metadata !DIExpression()), !dbg !20
runOnFunction: I:  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !21
runOnFunction: I:  ret void, !dbg !22
INSTCOMBINE ITERATION: Inst(start):  %A = icmp slt i32 %V1, 0, !dbg !15
INSTCOMBINE ITERATION: Inst(start):  call void @llvm.dbg.value(metadata i1 %A, metadata !9, metadata !DIExpression()), !dbg !15
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
INSTCOMBINE ITERATION: Inst(start):  %B = icmp slt i32 %V2, 0, !dbg !17
INSTCOMBINE ITERATION: Inst(start):  call void @llvm.dbg.value(metadata i1 %B, metadata !11, metadata !DIExpression()), !dbg !17
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !18
INSTCOMBINE ITERATION: Inst(start):  %and = and i32 %V1, 255, !dbg !19
INSTCOMBINE ITERATION: Inst(start):  call void @llvm.dbg.value(metadata i32 %and, metadata !12, metadata !DIExpression()), !dbg !19
INSTCOMBINE ITERATION: Inst(start):  %C = icmp sle i32 %and, 128, !dbg !20
INSTCOMBINE ITERATION: Inst(start):  call void @llvm.dbg.value(metadata i1 %C, metadata !14, metadata !DIExpression()), !dbg !20
INSTCOMBINE ITERATION: Inst(start):  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !21
INSTCOMBINE ITERATION: Inst(start):  ret void, !dbg !22


INSTCOMBINE ITERATION #1 on test_guard_adjacent_diff_cond2
INSTCOMBINE ITERATION: Inst(end):  %A = icmp slt i32 %V1, 0, !dbg !15
INSTCOMBINE ITERATION: Inst(end):  call void @llvm.dbg.value(metadata i1 %A, metadata !9, metadata !DIExpression()), !dbg !15
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
INSTCOMBINE ITERATION: Inst(end):  %B = icmp slt i32 %V2, 0, !dbg !17
INSTCOMBINE ITERATION: Inst(end):  call void @llvm.dbg.value(metadata i1 %B, metadata !11, metadata !DIExpression()), !dbg !17
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !18
INSTCOMBINE ITERATION: Inst(end):  %and = and i32 %V1, 255, !dbg !19
INSTCOMBINE ITERATION: Inst(end):  call void @llvm.dbg.value(metadata i32 %and, metadata !12, metadata !DIExpression()), !dbg !19
INSTCOMBINE ITERATION: Inst(end):  %C = icmp sle i32 %and, 128, !dbg !20
INSTCOMBINE ITERATION: Inst(end):  call void @llvm.dbg.value(metadata i1 %C, metadata !14, metadata !DIExpression()), !dbg !20
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !21
INSTCOMBINE ITERATION: Inst(end):  ret void, !dbg !22
chris-worklist-bb: bb: 
  %A = icmp slt i32 %V1, 0, !dbg !15
  call void @llvm.dbg.value(metadata i1 %A, metadata !9, metadata !DIExpression()), !dbg !15
  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
  %B = icmp slt i32 %V2, 0, !dbg !17
  call void @llvm.dbg.value(metadata i1 %B, metadata !11, metadata !DIExpression()), !dbg !17
  call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !18
  %and = and i32 %V1, 255, !dbg !19
  call void @llvm.dbg.value(metadata i32 %and, metadata !12, metadata !DIExpression()), !dbg !19
  %C = icmp sle i32 %and, 128, !dbg !20
  call void @llvm.dbg.value(metadata i1 %C, metadata !14, metadata !DIExpression()), !dbg !20
  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !21
  ret void, !dbg !22

chris-worklist-bb: BB: 
  %A = icmp slt i32 %V1, 0, !dbg !15
  call void @llvm.dbg.value(metadata i1 %A, metadata !9, metadata !DIExpression()), !dbg !15
  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
  %B = icmp slt i32 %V2, 0, !dbg !17
  call void @llvm.dbg.value(metadata i1 %B, metadata !11, metadata !DIExpression()), !dbg !17
  call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !18
  %and = and i32 %V1, 255, !dbg !19
  call void @llvm.dbg.value(metadata i32 %and, metadata !12, metadata !DIExpression()), !dbg !19
  %C = icmp sle i32 %and, 128, !dbg !20
  call void @llvm.dbg.value(metadata i1 %C, metadata !14, metadata !DIExpression()), !dbg !20
  call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !21
  ret void, !dbg !22

chris-worklist-bb: BB end:   %A = icmp slt i32 %V1, 0, !dbg !15
chris-worklist-bb: BB end: not push back:  call void @llvm.dbg.value(metadata i1 %A, metadata !9, metadata !DIExpression()), !dbg !15
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
chris-worklist-bb: BB end:   %B = icmp slt i32 %V2, 0, !dbg !17
chris-worklist-bb: BB end: not push back:  call void @llvm.dbg.value(metadata i1 %B, metadata !11, metadata !DIExpression()), !dbg !17
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !18
chris-worklist-bb: BB end:   %and = and i32 %V1, 255, !dbg !19
chris-worklist-bb: BB end: not push back:  call void @llvm.dbg.value(metadata i32 %and, metadata !12, metadata !DIExpression()), !dbg !19
chris-worklist-bb: BB end:   %C = icmp sle i32 %and, 128, !dbg !20
chris-worklist-bb: BB end: not push back:  call void @llvm.dbg.value(metadata i1 %C, metadata !14, metadata !DIExpression()), !dbg !20
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !21
chris-worklist-bb: BB end:   ret void, !dbg !22
IC: ADDING: 8 instrs to worklist
chris-AddInitialGroup: I:   ret void, !dbg !22
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !21
chris-AddInitialGroup: I:   %C = icmp sle i32 %and, 128, !dbg !20
chris-AddInitialGroup: I:   %and = and i32 %V1, 255, !dbg !19
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !18
chris-AddInitialGroup: I:   %B = icmp slt i32 %V2, 0, !dbg !17
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
chris-AddInitialGroup: I:   %A = icmp slt i32 %V1, 0, !dbg !15
RemoveOne!!!
chris-RemoveOne:   %A = icmp slt i32 %V1, 0, !dbg !15
chris-RemoveOne: return I  %A = icmp slt i32 %V1, 0, !dbg !15
run: WorkList:   %A = icmp slt i32 %V1, 0, !dbg !15
chris-run: I=  %A = icmp slt i32 %V1, 0, !dbg !15
chris-run: I-end=  %A = icmp slt i32 %V1, 0, !dbg !15
IC: Visiting:   %A = icmp slt i32 %V1, 0, !dbg !15
test1: I=  %A = icmp slt i32 %V1, 0, !dbg !15
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %A, i32 123) [ "deopt"() ], !dbg !16
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  %B = icmp slt i32 %V2, 0, !dbg !17
NextInst[0]   call void @llvm.dbg.value(metadata i1 %B, metadata !11, metadata !DIExpression()), !dbg !17
NextInst[1]   call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !18
 ok, break
Inst[end]:   call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !18
MoveI:   %B = icmp slt i32 %V2, 0, !dbg !17
chris add g: I:  %1 = and i1 %A, %B
IC: ADD:   %1 = and i1 %A, %B
IC: ERASE   call void (i1, ...) @llvm.experimental.guard(i1 %B, i32 456) [ "deopt"() ], !dbg !18
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %1 = and i1 %A, %B, !dbg !17
chris-RemoveOne: return I  %1 = and i1 %A, %B, !dbg !17
run: WorkList:   %1 = and i1 %A, %B, !dbg !17
chris-run: I=  %1 = and i1 %A, %B, !dbg !17
chris-run: I-end=  %1 = and i1 %A, %B, !dbg !17
IC: Visiting:   %1 = and i1 %A, %B, !dbg !17
test1: I=  %1 = and i1 %A, %B, !dbg !17
chris add g: I:  %1 = and i32 %V1, %V2
IC: ADD:   %1 = and i32 %V1, %V2
chris add g: I:  %2 = and i32 -2147483648, %1
IC: ADD:   %2 = and i32 -2147483648, %1
chris add g: I:  %3 = icmp eq i32 %2, -2147483648
IC: ADD:   %3 = icmp eq i32 %2, -2147483648
chris-add2:   call void (i1, ...) @llvm.experimental.guard(i1 %4, i32 123) [ "deopt"() ], !dbg !17
IC: ADD:   call void (i1, ...) @llvm.experimental.guard(i1 %4, i32 123) [ "deopt"() ], !dbg !17
IC: Replacing   %4 = and i1 %A, %B, !dbg !17
    with   %3 = icmp eq i32 %2, -2147483648, !dbg !17
visit: has:   %4 = and i1 %A, %B, !dbg !17
test2
after visiting: Result =   %4 = and i1 %A, %B, !dbg !17
after visiting: I =   %4 = and i1 %A, %B, !dbg !17
IC: Mod =   %1 = and i1 %A, %B, !dbg !17
    New =   %4 = and i1 %A, %B, !dbg !17
chris-Worklist.AddUsersToWorkList 3:   %4 = and i1 %A, %B, !dbg !17
IC: ERASE   %4 = and i1 %A, %B, !dbg !17
IC: ADD:   %A = icmp slt i32 %V1, 0, !dbg !15
test3
RemoveOne!!!
chris-RemoveOne:   %A = icmp slt i32 %V1, 0, !dbg !15
chris-RemoveOne: return I  %A = icmp slt i32 %V1, 0, !dbg !15
run: WorkList:   %A = icmp slt i32 %V1, 0, !dbg !15
chris-run: I=  %A = icmp slt i32 %V1, 0, !dbg !15
IC: DCE:   %A = icmp slt i32 %V1, 0, !dbg !15
IC: ERASE   %A = icmp slt i32 %V1, 0, !dbg !15
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !17
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !17
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !17
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !17
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !17
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !17
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !17
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !17
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  %and = and i32 %V1, 255, !dbg !18
NextInst[0]   call void @llvm.dbg.value(metadata i32 %and, metadata !12, metadata !DIExpression()), !dbg !18
NextInst[1]   %C = icmp sle i32 %and, 128, !dbg !19
NextInst[2]   call void @llvm.dbg.value(metadata i1 %C, metadata !14, metadata !DIExpression()), !dbg !19
NextInst[3]   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !20
 ok, break
Inst[end]:   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !20
MoveI:   %and = and i32 %V1, 255, !dbg !18
chris add g: I:  %4 = and i1 %3, %C
IC: ADD:   %4 = and i1 %3, %C
IC: ERASE   call void (i1, ...) @llvm.experimental.guard(i1 %C, i32 789) [ "deopt"() ], !dbg !20
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %4 = and i1 %3, %C, !dbg !17
chris-RemoveOne: return I  %4 = and i1 %3, %C, !dbg !17
run: WorkList:   %4 = and i1 %3, %C, !dbg !17
chris-run: I=  %4 = and i1 %3, %C, !dbg !17
chris-run: I-end=  %4 = and i1 %3, %C, !dbg !17
IC: Visiting:   %4 = and i1 %3, %C, !dbg !17
test1: I=  %4 = and i1 %3, %C, !dbg !17
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %3 = icmp eq i32 %2, -2147483648, !dbg !17
chris-RemoveOne: return I  %3 = icmp eq i32 %2, -2147483648, !dbg !17
run: WorkList:   %3 = icmp eq i32 %2, -2147483648, !dbg !17
chris-run: I=  %3 = icmp eq i32 %2, -2147483648, !dbg !17
chris-run: I-end=  %3 = icmp eq i32 %2, -2147483648, !dbg !17
IC: Visiting:   %3 = icmp eq i32 %2, -2147483648, !dbg !17
test1: I=  %3 = icmp eq i32 %2, -2147483648, !dbg !17
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %2 = and i32 -2147483648, %1, !dbg !17
chris-RemoveOne: return I  %2 = and i32 -2147483648, %1, !dbg !17
run: WorkList:   %2 = and i32 -2147483648, %1, !dbg !17
chris-run: I=  %2 = and i32 -2147483648, %1, !dbg !17
chris-run: I-end=  %2 = and i32 -2147483648, %1, !dbg !17
IC: Visiting:   %2 = and i32 -2147483648, %1, !dbg !17
test1: I=  %2 = and i32 -2147483648, %1, !dbg !17
visit: has:   %2 = and i32 %1, -2147483648, !dbg !17
test2
after visiting: Result =   %2 = and i32 %1, -2147483648, !dbg !17
after visiting: I =   %2 = and i32 %1, -2147483648, !dbg !17
IC: Mod =   %2 = and i32 -2147483648, %1, !dbg !17
    New =   %2 = and i32 %1, -2147483648, !dbg !17
chris-Worklist.AddUsersToWorkList 2:   %2 = and i32 %1, -2147483648, !dbg !17
chris-add2:   %3 = icmp eq i32 %2, -2147483648, !dbg !17
IC: ADD:   %3 = icmp eq i32 %2, -2147483648, !dbg !17
chris add f
IC: ADD:   %2 = and i32 %1, -2147483648, !dbg !17
test3
RemoveOne!!!
chris-RemoveOne:   %2 = and i32 %1, -2147483648, !dbg !17
chris-RemoveOne: return I  %2 = and i32 %1, -2147483648, !dbg !17
run: WorkList:   %2 = and i32 %1, -2147483648, !dbg !17
chris-run: I=  %2 = and i32 %1, -2147483648, !dbg !17
chris-run: I-end=  %2 = and i32 %1, -2147483648, !dbg !17
IC: Visiting:   %2 = and i32 %1, -2147483648, !dbg !17
test1: I=  %2 = and i32 %1, -2147483648, !dbg !17
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %3 = icmp eq i32 %2, -2147483648, !dbg !17
chris-RemoveOne: return I  %3 = icmp eq i32 %2, -2147483648, !dbg !17
run: WorkList:   %3 = icmp eq i32 %2, -2147483648, !dbg !17
chris-run: I=  %3 = icmp eq i32 %2, -2147483648, !dbg !17
chris-run: I-end=  %3 = icmp eq i32 %2, -2147483648, !dbg !17
IC: Visiting:   %3 = icmp eq i32 %2, -2147483648, !dbg !17
test1: I=  %3 = icmp eq i32 %2, -2147483648, !dbg !17
visit: has:   <badref> = icmp ugt i32 %1, 2147483647
test2
after visiting: Result =   <badref> = icmp ugt i32 %1, 2147483647
after visiting: I =   %3 = icmp eq i32 %2, -2147483648, !dbg !17
IC: Old =   %3 = icmp eq i32 %2, -2147483648, !dbg !17
    New =   <badref> = icmp ugt i32 %1, 2147483647
chris-Worklist.AddUsersToWorkList 1
chris-add2:   %4 = and i1 <badref>, %C, !dbg !17
IC: ADD:   %4 = and i1 <badref>, %C, !dbg !17
chris add e
IC: ADD:   <badref> = icmp ugt i32 %1, 2147483647, !dbg !DILocation(line: 2, column: 1, scope: <0x560bd8df6a20>)
IC: ERASE   %4 = icmp eq i32 %2, -2147483648, !dbg !17
IC: ADD:   %2 = and i32 %1, -2147483648, !dbg !17
test3
RemoveOne!!!
chris-RemoveOne:   %2 = and i32 %1, -2147483648, !dbg !17
chris-RemoveOne: return I  %2 = and i32 %1, -2147483648, !dbg !17
run: WorkList:   %2 = and i32 %1, -2147483648, !dbg !17
chris-run: I=  %2 = and i32 %1, -2147483648, !dbg !17
IC: DCE:   %2 = and i32 %1, -2147483648, !dbg !17
IC: ERASE   %2 = and i32 %1, -2147483648, !dbg !17
RemoveOne!!!
chris-RemoveOne:   %2 = icmp ugt i32 %1, 2147483647, !dbg !17
chris-RemoveOne: return I  %2 = icmp ugt i32 %1, 2147483647, !dbg !17
run: WorkList:   %2 = icmp ugt i32 %1, 2147483647, !dbg !17
chris-run: I=  %2 = icmp ugt i32 %1, 2147483647, !dbg !17
chris-run: I-end=  %2 = icmp ugt i32 %1, 2147483647, !dbg !17
IC: Visiting:   %2 = icmp ugt i32 %1, 2147483647, !dbg !17
test1: I=  %2 = icmp ugt i32 %1, 2147483647, !dbg !17
visit: has:   <badref> = icmp slt i32 %1, 0
test2
after visiting: Result =   <badref> = icmp slt i32 %1, 0
after visiting: I =   %2 = icmp ugt i32 %1, 2147483647, !dbg !17
IC: Old =   %2 = icmp ugt i32 %1, 2147483647, !dbg !17
    New =   <badref> = icmp slt i32 %1, 0
chris-Worklist.AddUsersToWorkList 1
chris-add2:   %3 = and i1 <badref>, %C, !dbg !17
chris add e
IC: ADD:   <badref> = icmp slt i32 %1, 0, !dbg !DILocation(line: 2, column: 1, scope: <0x560bd8df6a20>)
IC: ERASE   %3 = icmp ugt i32 %1, 2147483647, !dbg !17
test3
RemoveOne!!!
chris-RemoveOne:   %2 = icmp slt i32 %1, 0, !dbg !17
chris-RemoveOne: return I  %2 = icmp slt i32 %1, 0, !dbg !17
run: WorkList:   %2 = icmp slt i32 %1, 0, !dbg !17
chris-run: I=  %2 = icmp slt i32 %1, 0, !dbg !17
chris-run: I-end=  %2 = icmp slt i32 %1, 0, !dbg !17
IC: Visiting:   %2 = icmp slt i32 %1, 0, !dbg !17
test1: I=  %2 = icmp slt i32 %1, 0, !dbg !17
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %3 = and i1 %2, %C, !dbg !17
chris-RemoveOne: return I  %3 = and i1 %2, %C, !dbg !17
run: WorkList:   %3 = and i1 %2, %C, !dbg !17
chris-run: I=  %3 = and i1 %2, %C, !dbg !17
chris-run: I-end=  %3 = and i1 %2, %C, !dbg !17
IC: Visiting:   %3 = and i1 %2, %C, !dbg !17
test1: I=  %3 = and i1 %2, %C, !dbg !17
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %1 = and i32 %V1, %V2, !dbg !17
chris-RemoveOne: return I  %1 = and i32 %V1, %V2, !dbg !17
run: WorkList:   %1 = and i32 %V1, %V2, !dbg !17
chris-run: I=  %1 = and i32 %V1, %V2, !dbg !17
chris-run: I-end=  %1 = and i32 %V1, %V2, !dbg !17
IC: Visiting:   %1 = and i32 %V1, %V2, !dbg !17
test1: I=  %1 = and i32 %V1, %V2, !dbg !17
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %B = icmp slt i32 %V2, 0, !dbg !16
chris-RemoveOne: return I  %B = icmp slt i32 %V2, 0, !dbg !16
run: WorkList:   %B = icmp slt i32 %V2, 0, !dbg !16
chris-run: I=  %B = icmp slt i32 %V2, 0, !dbg !16
IC: DCE:   %B = icmp slt i32 %V2, 0, !dbg !16
IC: ERASE   %B = icmp slt i32 %V2, 0, !dbg !16
RemoveOne!!!
run: WorkList: null
RemoveOne!!!
chris-RemoveOne:   %and = and i32 %V1, 255, !dbg !18
chris-RemoveOne: return I  %and = and i32 %V1, 255, !dbg !18
run: WorkList:   %and = and i32 %V1, 255, !dbg !18
chris-run: I=  %and = and i32 %V1, 255, !dbg !18
chris-run: I-end=  %and = and i32 %V1, 255, !dbg !18
IC: Visiting:   %and = and i32 %V1, 255, !dbg !18
test1: I=  %and = and i32 %V1, 255, !dbg !18
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %C = icmp sle i32 %and, 128, !dbg !19
chris-RemoveOne: return I  %C = icmp sle i32 %and, 128, !dbg !19
run: WorkList:   %C = icmp sle i32 %and, 128, !dbg !19
chris-run: I=  %C = icmp sle i32 %and, 128, !dbg !19
chris-run: I-end=  %C = icmp sle i32 %and, 128, !dbg !19
IC: Visiting:   %C = icmp sle i32 %and, 128, !dbg !19
test1: I=  %C = icmp sle i32 %and, 128, !dbg !19
visit: has:   <badref> = icmp slt i32 %and, 129
test2
after visiting: Result =   <badref> = icmp slt i32 %and, 129
after visiting: I =   %C = icmp sle i32 %and, 128, !dbg !19
IC: Old =   %C = icmp sle i32 %and, 128, !dbg !19
    New =   <badref> = icmp slt i32 %and, 129
chris-Worklist.AddUsersToWorkList 1
chris-add2:   %4 = and i1 %2, %C, !dbg !17
IC: ADD:   %4 = and i1 %2, %C, !dbg !17
chris add e
IC: ADD:   %C = icmp slt i32 %and, 129, !dbg !DILocation(line: 6, column: 1, scope: <0x560bd8df6a20>)
IC: ERASE   %3 = icmp sle i32 %and, 128, !dbg !19
IC: ADD:   %and = and i32 %V1, 255, !dbg !18
test3
RemoveOne!!!
chris-RemoveOne:   %and = and i32 %V1, 255, !dbg !18
chris-RemoveOne: return I  %and = and i32 %V1, 255, !dbg !18
run: WorkList:   %and = and i32 %V1, 255, !dbg !18
chris-run: I=  %and = and i32 %V1, 255, !dbg !18
chris-run: I-end=  %and = and i32 %V1, 255, !dbg !18
IC: Visiting:   %and = and i32 %V1, 255, !dbg !18
test1: I=  %and = and i32 %V1, 255, !dbg !18
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %C = icmp slt i32 %and, 129, !dbg !19
chris-RemoveOne: return I  %C = icmp slt i32 %and, 129, !dbg !19
run: WorkList:   %C = icmp slt i32 %and, 129, !dbg !19
chris-run: I=  %C = icmp slt i32 %and, 129, !dbg !19
chris-run: I-end=  %C = icmp slt i32 %and, 129, !dbg !19
IC: Visiting:   %C = icmp slt i32 %and, 129, !dbg !19
test1: I=  %C = icmp slt i32 %and, 129, !dbg !19
visit: has:   <badref> = icmp ult i32 %and, 129
test2
after visiting: Result =   <badref> = icmp ult i32 %and, 129
after visiting: I =   %C = icmp slt i32 %and, 129, !dbg !19
IC: Old =   %C = icmp slt i32 %and, 129, !dbg !19
    New =   <badref> = icmp ult i32 %and, 129
chris-Worklist.AddUsersToWorkList 1
chris-add2:   %4 = and i1 %2, %C, !dbg !17
chris add e
IC: ADD:   %C = icmp ult i32 %and, 129, !dbg !DILocation(line: 6, column: 1, scope: <0x560bd8df6a20>)
IC: ERASE   %3 = icmp slt i32 %and, 129, !dbg !19
IC: ADD:   %and = and i32 %V1, 255, !dbg !18
test3
RemoveOne!!!
chris-RemoveOne:   %and = and i32 %V1, 255, !dbg !18
chris-RemoveOne: return I  %and = and i32 %V1, 255, !dbg !18
run: WorkList:   %and = and i32 %V1, 255, !dbg !18
chris-run: I=  %and = and i32 %V1, 255, !dbg !18
chris-run: I-end=  %and = and i32 %V1, 255, !dbg !18
IC: Visiting:   %and = and i32 %V1, 255, !dbg !18
test1: I=  %and = and i32 %V1, 255, !dbg !18
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %C = icmp ult i32 %and, 129, !dbg !19
chris-RemoveOne: return I  %C = icmp ult i32 %and, 129, !dbg !19
run: WorkList:   %C = icmp ult i32 %and, 129, !dbg !19
chris-run: I=  %C = icmp ult i32 %and, 129, !dbg !19
chris-run: I-end=  %C = icmp ult i32 %and, 129, !dbg !19
IC: Visiting:   %C = icmp ult i32 %and, 129, !dbg !19
test1: I=  %C = icmp ult i32 %and, 129, !dbg !19
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %3 = and i1 %2, %C, !dbg !17
chris-RemoveOne: return I  %3 = and i1 %2, %C, !dbg !17
run: WorkList:   %3 = and i1 %2, %C, !dbg !17
chris-run: I=  %3 = and i1 %2, %C, !dbg !17
chris-run: I-end=  %3 = and i1 %2, %C, !dbg !17
IC: Visiting:   %3 = and i1 %2, %C, !dbg !17
test1: I=  %3 = and i1 %2, %C, !dbg !17
visit: nullptr 
test3
RemoveOne!!!
run: WorkList: null
RemoveOne!!!
chris-RemoveOne:   ret void, !dbg !20
chris-RemoveOne: return I  ret void, !dbg !20
run: WorkList:   ret void, !dbg !20
chris-run: I=  ret void, !dbg !20
chris-run: I-end=  ret void, !dbg !20
IC: Visiting:   ret void, !dbg !20
test1: I=  ret void, !dbg !20
visit: nullptr 
test3
test4


INSTCOMBINE ITERATION #2 on test_guard_adjacent_diff_cond2
INSTCOMBINE ITERATION: Inst(end):  call void @llvm.dbg.value(metadata !3, metadata !9, metadata !DIExpression()), !dbg !15
INSTCOMBINE ITERATION: Inst(end):  call void @llvm.dbg.value(metadata !3, metadata !11, metadata !DIExpression()), !dbg !16
INSTCOMBINE ITERATION: Inst(end):  %1 = and i32 %V1, %V2, !dbg !17
INSTCOMBINE ITERATION: Inst(end):  %2 = icmp slt i32 %1, 0, !dbg !17
INSTCOMBINE ITERATION: Inst(end):  %and = and i32 %V1, 255, !dbg !18
INSTCOMBINE ITERATION: Inst(end):  call void @llvm.dbg.value(metadata i32 %and, metadata !12, metadata !DIExpression()), !dbg !18
INSTCOMBINE ITERATION: Inst(end):  %C = icmp ult i32 %and, 129, !dbg !19
INSTCOMBINE ITERATION: Inst(end):  call void @llvm.dbg.value(metadata i1 %C, metadata !14, metadata !DIExpression()), !dbg !19
INSTCOMBINE ITERATION: Inst(end):  %3 = and i1 %2, %C, !dbg !17
INSTCOMBINE ITERATION: Inst(end):  call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !17
INSTCOMBINE ITERATION: Inst(end):  ret void, !dbg !20
chris-worklist-bb: bb: 
  call void @llvm.dbg.value(metadata !3, metadata !9, metadata !DIExpression()), !dbg !15
  call void @llvm.dbg.value(metadata !3, metadata !11, metadata !DIExpression()), !dbg !16
  %1 = and i32 %V1, %V2, !dbg !17
  %2 = icmp slt i32 %1, 0, !dbg !17
  %and = and i32 %V1, 255, !dbg !18
  call void @llvm.dbg.value(metadata i32 %and, metadata !12, metadata !DIExpression()), !dbg !18
  %C = icmp ult i32 %and, 129, !dbg !19
  call void @llvm.dbg.value(metadata i1 %C, metadata !14, metadata !DIExpression()), !dbg !19
  %3 = and i1 %2, %C, !dbg !17
  call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !17
  ret void, !dbg !20

chris-worklist-bb: BB: 
  call void @llvm.dbg.value(metadata !3, metadata !9, metadata !DIExpression()), !dbg !15
  call void @llvm.dbg.value(metadata !3, metadata !11, metadata !DIExpression()), !dbg !16
  %1 = and i32 %V1, %V2, !dbg !17
  %2 = icmp slt i32 %1, 0, !dbg !17
  %and = and i32 %V1, 255, !dbg !18
  call void @llvm.dbg.value(metadata i32 %and, metadata !12, metadata !DIExpression()), !dbg !18
  %C = icmp ult i32 %and, 129, !dbg !19
  call void @llvm.dbg.value(metadata i1 %C, metadata !14, metadata !DIExpression()), !dbg !19
  %3 = and i1 %2, %C, !dbg !17
  call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !17
  ret void, !dbg !20

IC: DCE:   call void @llvm.dbg.value(metadata !3, metadata !9, metadata !DIExpression()), !dbg !15
IC: DCE:   call void @llvm.dbg.value(metadata !3, metadata !11, metadata !DIExpression()), !dbg !15
chris-worklist-bb: BB end:   %1 = and i32 %V1, %V2, !dbg !15
chris-worklist-bb: BB end:   %2 = icmp slt i32 %1, 0, !dbg !15
chris-worklist-bb: BB end:   %and = and i32 %V1, 255, !dbg !16
chris-worklist-bb: BB end: not push back:  call void @llvm.dbg.value(metadata i32 %and, metadata !12, metadata !DIExpression()), !dbg !16
chris-worklist-bb: BB end:   %C = icmp ult i32 %and, 129, !dbg !17
chris-worklist-bb: BB end: not push back:  call void @llvm.dbg.value(metadata i1 %C, metadata !14, metadata !DIExpression()), !dbg !17
chris-worklist-bb: BB end:   %3 = and i1 %2, %C, !dbg !15
chris-worklist-bb: BB end:   call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !15
chris-worklist-bb: BB end:   ret void, !dbg !18
IC: ADDING: 7 instrs to worklist
chris-AddInitialGroup: I:   ret void, !dbg !18
chris-AddInitialGroup: I:   call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !15
chris-AddInitialGroup: I:   %3 = and i1 %2, %C, !dbg !15
chris-AddInitialGroup: I:   %C = icmp ult i32 %and, 129, !dbg !17
chris-AddInitialGroup: I:   %and = and i32 %V1, 255, !dbg !16
chris-AddInitialGroup: I:   %2 = icmp slt i32 %1, 0, !dbg !15
chris-AddInitialGroup: I:   %1 = and i32 %V1, %V2, !dbg !15
RemoveOne!!!
chris-RemoveOne:   %1 = and i32 %V1, %V2, !dbg !15
chris-RemoveOne: return I  %1 = and i32 %V1, %V2, !dbg !15
run: WorkList:   %1 = and i32 %V1, %V2, !dbg !15
chris-run: I=  %1 = and i32 %V1, %V2, !dbg !15
chris-run: I-end=  %1 = and i32 %V1, %V2, !dbg !15
IC: Visiting:   %1 = and i32 %V1, %V2, !dbg !15
test1: I=  %1 = and i32 %V1, %V2, !dbg !15
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %2 = icmp slt i32 %1, 0, !dbg !15
chris-RemoveOne: return I  %2 = icmp slt i32 %1, 0, !dbg !15
run: WorkList:   %2 = icmp slt i32 %1, 0, !dbg !15
chris-run: I=  %2 = icmp slt i32 %1, 0, !dbg !15
chris-run: I-end=  %2 = icmp slt i32 %1, 0, !dbg !15
IC: Visiting:   %2 = icmp slt i32 %1, 0, !dbg !15
test1: I=  %2 = icmp slt i32 %1, 0, !dbg !15
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %and = and i32 %V1, 255, !dbg !16
chris-RemoveOne: return I  %and = and i32 %V1, 255, !dbg !16
run: WorkList:   %and = and i32 %V1, 255, !dbg !16
chris-run: I=  %and = and i32 %V1, 255, !dbg !16
chris-run: I-end=  %and = and i32 %V1, 255, !dbg !16
IC: Visiting:   %and = and i32 %V1, 255, !dbg !16
test1: I=  %and = and i32 %V1, 255, !dbg !16
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %C = icmp ult i32 %and, 129, !dbg !17
chris-RemoveOne: return I  %C = icmp ult i32 %and, 129, !dbg !17
run: WorkList:   %C = icmp ult i32 %and, 129, !dbg !17
chris-run: I=  %C = icmp ult i32 %and, 129, !dbg !17
chris-run: I-end=  %C = icmp ult i32 %and, 129, !dbg !17
IC: Visiting:   %C = icmp ult i32 %and, 129, !dbg !17
test1: I=  %C = icmp ult i32 %and, 129, !dbg !17
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   %3 = and i1 %2, %C, !dbg !15
chris-RemoveOne: return I  %3 = and i1 %2, %C, !dbg !15
run: WorkList:   %3 = and i1 %2, %C, !dbg !15
chris-run: I=  %3 = and i1 %2, %C, !dbg !15
chris-run: I-end=  %3 = and i1 %2, %C, !dbg !15
IC: Visiting:   %3 = and i1 %2, %C, !dbg !15
test1: I=  %3 = and i1 %2, %C, !dbg !15
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !15
chris-RemoveOne: return I  call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !15
run: WorkList:   call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !15
chris-run: I=  call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !15
chris-run: I-end=  call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !15
IC: Visiting:   call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !15
test1: I=  call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !15
chris-debug7
  II:   call void (i1, ...) @llvm.experimental.guard(i1 %3, i32 123) [ "deopt"() ], !dbg !15
  IID: 96
  experimental_guard: 96
GuardWideningWindow: 10
Inst[start]:  ret void, !dbg !18
 ok, break
Inst[end]:   ret void, !dbg !18
chris-debug7-8
chris-debug4
visit: nullptr 
test3
RemoveOne!!!
chris-RemoveOne:   ret void, !dbg !18
chris-RemoveOne: return I  ret void, !dbg !18
run: WorkList:   ret void, !dbg !18
chris-run: I=  ret void, !dbg !18
chris-run: I-end=  ret void, !dbg !18
IC: Visiting:   ret void, !dbg !18
test1: I=  ret void, !dbg !18
visit: nullptr 
test3
test4
WARNING: Missing line 1
WARNING: Missing line 3
WARNING: Missing line 4
WARNING: Missing line 7
WARNING: Missing variable 1
WARNING: Missing variable 2
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (40) Simplify the CFG on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (41) Combine redundant instructions on function (negative_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (42) Simplify the CFG on function (negative_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (43) Combine redundant instructions on function (deref_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (44) Simplify the CFG on function (deref_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (45) Combine redundant instructions on function (negative_div)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (46) Simplify the CFG on function (negative_div)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (47) Combine redundant instructions on function (negative_window)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (48) Simplify the CFG on function (negative_window)
CheckFunctionDebugify [Simplify the CFG]: PASS
CheckModuleDebugify [Globals Alias Analysis]: PASS
BISECT: NOT running pass (49) Remove unused exception handling info on SCC (llvm.experimental.guard)
BISECT: NOT running pass (50) Deduce function attributes on SCC (llvm.experimental.guard)
BISECT: NOT running pass (51) Remove unused exception handling info on SCC (test_guard_adjacent_same_cond)
BISECT: NOT running pass (52) Deduce function attributes on SCC (test_guard_adjacent_same_cond)
BISECT: NOT running pass (53) SROA on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [SROA]: PASS
BISECT: NOT running pass (54) Early CSE w/ MemorySSA on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Early CSE w/ MemorySSA]: PASS
BISECT: NOT running pass (55) Speculatively execute instructions if target has divergent branches on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Speculatively execute instructions if target has divergent branches]: PASS
BISECT: NOT running pass (56) Jump Threading on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (57) Value Propagation on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (58) Simplify the CFG on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (59) Combine redundant instructions on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
CheckFunctionDebugify [Conditionally eliminate dead library calls]: PASS
CheckFunctionDebugify [PGOMemOPSize]: PASS
BISECT: NOT running pass (60) Tail Call Elimination on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Tail Call Elimination]: PASS
BISECT: NOT running pass (61) Simplify the CFG on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (62) Reassociate expressions on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Reassociate expressions]: PASS
BISECT: NOT running pass (63) Simplify the CFG on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (64) Combine redundant instructions on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (65) MemCpy Optimization on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [MemCpy Optimization]: PASS
BISECT: NOT running pass (66) Sparse Conditional Constant Propagation on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Sparse Conditional Constant Propagation]: PASS
BISECT: NOT running pass (67) Bit-Tracking Dead Code Elimination on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Bit-Tracking Dead Code Elimination]: PASS
BISECT: NOT running pass (68) Combine redundant instructions on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (69) Jump Threading on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (70) Value Propagation on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (71) Dead Store Elimination on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Dead Store Elimination]: PASS
BISECT: NOT running pass (72) Aggressive Dead Code Elimination on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Aggressive Dead Code Elimination]: PASS
BISECT: NOT running pass (73) Simplify the CFG on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (74) Combine redundant instructions on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (75) Remove unused exception handling info on SCC (test_guard_adjacent_diff_cond)
BISECT: NOT running pass (76) Deduce function attributes on SCC (test_guard_adjacent_diff_cond)
BISECT: NOT running pass (77) SROA on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [SROA]: PASS
BISECT: NOT running pass (78) Early CSE w/ MemorySSA on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Early CSE w/ MemorySSA]: PASS
BISECT: NOT running pass (79) Speculatively execute instructions if target has divergent branches on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Speculatively execute instructions if target has divergent branches]: PASS
BISECT: NOT running pass (80) Jump Threading on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (81) Value Propagation on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (82) Simplify the CFG on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (83) Combine redundant instructions on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
CheckFunctionDebugify [Conditionally eliminate dead library calls]: PASS
CheckFunctionDebugify [PGOMemOPSize]: PASS
BISECT: NOT running pass (84) Tail Call Elimination on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Tail Call Elimination]: PASS
BISECT: NOT running pass (85) Simplify the CFG on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (86) Reassociate expressions on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Reassociate expressions]: PASS
BISECT: NOT running pass (87) Simplify the CFG on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (88) Combine redundant instructions on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (89) MemCpy Optimization on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [MemCpy Optimization]: PASS
BISECT: NOT running pass (90) Sparse Conditional Constant Propagation on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Sparse Conditional Constant Propagation]: PASS
BISECT: NOT running pass (91) Bit-Tracking Dead Code Elimination on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Bit-Tracking Dead Code Elimination]: PASS
BISECT: NOT running pass (92) Combine redundant instructions on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (93) Jump Threading on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (94) Value Propagation on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (95) Dead Store Elimination on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Dead Store Elimination]: PASS
BISECT: NOT running pass (96) Aggressive Dead Code Elimination on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Aggressive Dead Code Elimination]: PASS
BISECT: NOT running pass (97) Simplify the CFG on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (98) Combine redundant instructions on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (99) Remove unused exception handling info on SCC (test_guard_adjacent_diff_cond2)
BISECT: NOT running pass (100) Deduce function attributes on SCC (test_guard_adjacent_diff_cond2)
BISECT: NOT running pass (101) SROA on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [SROA]: PASS
BISECT: NOT running pass (102) Early CSE w/ MemorySSA on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Early CSE w/ MemorySSA]: PASS
BISECT: NOT running pass (103) Speculatively execute instructions if target has divergent branches on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Speculatively execute instructions if target has divergent branches]: PASS
BISECT: NOT running pass (104) Jump Threading on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (105) Value Propagation on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (106) Simplify the CFG on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (107) Combine redundant instructions on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Combine redundant instructions]: PASS
CheckFunctionDebugify [Conditionally eliminate dead library calls]: PASS
CheckFunctionDebugify [PGOMemOPSize]: PASS
BISECT: NOT running pass (108) Tail Call Elimination on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Tail Call Elimination]: PASS
BISECT: NOT running pass (109) Simplify the CFG on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (110) Reassociate expressions on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Reassociate expressions]: PASS
BISECT: NOT running pass (111) Simplify the CFG on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (112) Combine redundant instructions on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (113) MemCpy Optimization on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [MemCpy Optimization]: PASS
BISECT: NOT running pass (114) Sparse Conditional Constant Propagation on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Sparse Conditional Constant Propagation]: PASS
BISECT: NOT running pass (115) Bit-Tracking Dead Code Elimination on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Bit-Tracking Dead Code Elimination]: PASS
BISECT: NOT running pass (116) Combine redundant instructions on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (117) Jump Threading on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (118) Value Propagation on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (119) Dead Store Elimination on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Dead Store Elimination]: PASS
BISECT: NOT running pass (120) Aggressive Dead Code Elimination on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Aggressive Dead Code Elimination]: PASS
BISECT: NOT running pass (121) Simplify the CFG on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (122) Combine redundant instructions on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (123) Remove unused exception handling info on SCC (negative_load)
BISECT: NOT running pass (124) Deduce function attributes on SCC (negative_load)
BISECT: NOT running pass (125) SROA on function (negative_load)
CheckFunctionDebugify [SROA]: PASS
BISECT: NOT running pass (126) Early CSE w/ MemorySSA on function (negative_load)
CheckFunctionDebugify [Early CSE w/ MemorySSA]: PASS
BISECT: NOT running pass (127) Speculatively execute instructions if target has divergent branches on function (negative_load)
CheckFunctionDebugify [Speculatively execute instructions if target has divergent branches]: PASS
BISECT: NOT running pass (128) Jump Threading on function (negative_load)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (129) Value Propagation on function (negative_load)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (130) Simplify the CFG on function (negative_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (131) Combine redundant instructions on function (negative_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
CheckFunctionDebugify [Conditionally eliminate dead library calls]: PASS
CheckFunctionDebugify [PGOMemOPSize]: PASS
BISECT: NOT running pass (132) Tail Call Elimination on function (negative_load)
CheckFunctionDebugify [Tail Call Elimination]: PASS
BISECT: NOT running pass (133) Simplify the CFG on function (negative_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (134) Reassociate expressions on function (negative_load)
CheckFunctionDebugify [Reassociate expressions]: PASS
BISECT: NOT running pass (135) Simplify the CFG on function (negative_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (136) Combine redundant instructions on function (negative_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (137) MemCpy Optimization on function (negative_load)
CheckFunctionDebugify [MemCpy Optimization]: PASS
BISECT: NOT running pass (138) Sparse Conditional Constant Propagation on function (negative_load)
CheckFunctionDebugify [Sparse Conditional Constant Propagation]: PASS
BISECT: NOT running pass (139) Bit-Tracking Dead Code Elimination on function (negative_load)
CheckFunctionDebugify [Bit-Tracking Dead Code Elimination]: PASS
BISECT: NOT running pass (140) Combine redundant instructions on function (negative_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (141) Jump Threading on function (negative_load)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (142) Value Propagation on function (negative_load)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (143) Dead Store Elimination on function (negative_load)
CheckFunctionDebugify [Dead Store Elimination]: PASS
BISECT: NOT running pass (144) Aggressive Dead Code Elimination on function (negative_load)
CheckFunctionDebugify [Aggressive Dead Code Elimination]: PASS
BISECT: NOT running pass (145) Simplify the CFG on function (negative_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (146) Combine redundant instructions on function (negative_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (147) Remove unused exception handling info on SCC (deref_load)
BISECT: NOT running pass (148) Deduce function attributes on SCC (deref_load)
BISECT: NOT running pass (149) SROA on function (deref_load)
CheckFunctionDebugify [SROA]: PASS
BISECT: NOT running pass (150) Early CSE w/ MemorySSA on function (deref_load)
CheckFunctionDebugify [Early CSE w/ MemorySSA]: PASS
BISECT: NOT running pass (151) Speculatively execute instructions if target has divergent branches on function (deref_load)
CheckFunctionDebugify [Speculatively execute instructions if target has divergent branches]: PASS
BISECT: NOT running pass (152) Jump Threading on function (deref_load)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (153) Value Propagation on function (deref_load)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (154) Simplify the CFG on function (deref_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (155) Combine redundant instructions on function (deref_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
CheckFunctionDebugify [Conditionally eliminate dead library calls]: PASS
CheckFunctionDebugify [PGOMemOPSize]: PASS
BISECT: NOT running pass (156) Tail Call Elimination on function (deref_load)
CheckFunctionDebugify [Tail Call Elimination]: PASS
BISECT: NOT running pass (157) Simplify the CFG on function (deref_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (158) Reassociate expressions on function (deref_load)
CheckFunctionDebugify [Reassociate expressions]: PASS
BISECT: NOT running pass (159) Simplify the CFG on function (deref_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (160) Combine redundant instructions on function (deref_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (161) MemCpy Optimization on function (deref_load)
CheckFunctionDebugify [MemCpy Optimization]: PASS
BISECT: NOT running pass (162) Sparse Conditional Constant Propagation on function (deref_load)
CheckFunctionDebugify [Sparse Conditional Constant Propagation]: PASS
BISECT: NOT running pass (163) Bit-Tracking Dead Code Elimination on function (deref_load)
CheckFunctionDebugify [Bit-Tracking Dead Code Elimination]: PASS
BISECT: NOT running pass (164) Combine redundant instructions on function (deref_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (165) Jump Threading on function (deref_load)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (166) Value Propagation on function (deref_load)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (167) Dead Store Elimination on function (deref_load)
CheckFunctionDebugify [Dead Store Elimination]: PASS
BISECT: NOT running pass (168) Aggressive Dead Code Elimination on function (deref_load)
CheckFunctionDebugify [Aggressive Dead Code Elimination]: PASS
BISECT: NOT running pass (169) Simplify the CFG on function (deref_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (170) Combine redundant instructions on function (deref_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (171) Remove unused exception handling info on SCC (negative_div)
BISECT: NOT running pass (172) Deduce function attributes on SCC (negative_div)
BISECT: NOT running pass (173) SROA on function (negative_div)
CheckFunctionDebugify [SROA]: PASS
BISECT: NOT running pass (174) Early CSE w/ MemorySSA on function (negative_div)
CheckFunctionDebugify [Early CSE w/ MemorySSA]: PASS
BISECT: NOT running pass (175) Speculatively execute instructions if target has divergent branches on function (negative_div)
CheckFunctionDebugify [Speculatively execute instructions if target has divergent branches]: PASS
BISECT: NOT running pass (176) Jump Threading on function (negative_div)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (177) Value Propagation on function (negative_div)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (178) Simplify the CFG on function (negative_div)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (179) Combine redundant instructions on function (negative_div)
CheckFunctionDebugify [Combine redundant instructions]: PASS
CheckFunctionDebugify [Conditionally eliminate dead library calls]: PASS
CheckFunctionDebugify [PGOMemOPSize]: PASS
BISECT: NOT running pass (180) Tail Call Elimination on function (negative_div)
CheckFunctionDebugify [Tail Call Elimination]: PASS
BISECT: NOT running pass (181) Simplify the CFG on function (negative_div)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (182) Reassociate expressions on function (negative_div)
CheckFunctionDebugify [Reassociate expressions]: PASS
BISECT: NOT running pass (183) Simplify the CFG on function (negative_div)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (184) Combine redundant instructions on function (negative_div)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (185) MemCpy Optimization on function (negative_div)
CheckFunctionDebugify [MemCpy Optimization]: PASS
BISECT: NOT running pass (186) Sparse Conditional Constant Propagation on function (negative_div)
CheckFunctionDebugify [Sparse Conditional Constant Propagation]: PASS
BISECT: NOT running pass (187) Bit-Tracking Dead Code Elimination on function (negative_div)
CheckFunctionDebugify [Bit-Tracking Dead Code Elimination]: PASS
BISECT: NOT running pass (188) Combine redundant instructions on function (negative_div)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (189) Jump Threading on function (negative_div)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (190) Value Propagation on function (negative_div)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (191) Dead Store Elimination on function (negative_div)
CheckFunctionDebugify [Dead Store Elimination]: PASS
BISECT: NOT running pass (192) Aggressive Dead Code Elimination on function (negative_div)
CheckFunctionDebugify [Aggressive Dead Code Elimination]: PASS
BISECT: NOT running pass (193) Simplify the CFG on function (negative_div)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (194) Combine redundant instructions on function (negative_div)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (195) Remove unused exception handling info on SCC (negative_window)
BISECT: NOT running pass (196) Deduce function attributes on SCC (negative_window)
BISECT: NOT running pass (197) SROA on function (negative_window)
CheckFunctionDebugify [SROA]: PASS
BISECT: NOT running pass (198) Early CSE w/ MemorySSA on function (negative_window)
CheckFunctionDebugify [Early CSE w/ MemorySSA]: PASS
BISECT: NOT running pass (199) Speculatively execute instructions if target has divergent branches on function (negative_window)
CheckFunctionDebugify [Speculatively execute instructions if target has divergent branches]: PASS
BISECT: NOT running pass (200) Jump Threading on function (negative_window)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (201) Value Propagation on function (negative_window)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (202) Simplify the CFG on function (negative_window)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (203) Combine redundant instructions on function (negative_window)
CheckFunctionDebugify [Combine redundant instructions]: PASS
CheckFunctionDebugify [Conditionally eliminate dead library calls]: PASS
CheckFunctionDebugify [PGOMemOPSize]: PASS
BISECT: NOT running pass (204) Tail Call Elimination on function (negative_window)
CheckFunctionDebugify [Tail Call Elimination]: PASS
BISECT: NOT running pass (205) Simplify the CFG on function (negative_window)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (206) Reassociate expressions on function (negative_window)
CheckFunctionDebugify [Reassociate expressions]: PASS
BISECT: NOT running pass (207) Simplify the CFG on function (negative_window)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (208) Combine redundant instructions on function (negative_window)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (209) MemCpy Optimization on function (negative_window)
CheckFunctionDebugify [MemCpy Optimization]: PASS
BISECT: NOT running pass (210) Sparse Conditional Constant Propagation on function (negative_window)
CheckFunctionDebugify [Sparse Conditional Constant Propagation]: PASS
BISECT: NOT running pass (211) Bit-Tracking Dead Code Elimination on function (negative_window)
CheckFunctionDebugify [Bit-Tracking Dead Code Elimination]: PASS
BISECT: NOT running pass (212) Combine redundant instructions on function (negative_window)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (213) Jump Threading on function (negative_window)
CheckFunctionDebugify [Jump Threading]: PASS
BISECT: NOT running pass (214) Value Propagation on function (negative_window)
CheckFunctionDebugify [Value Propagation]: PASS
BISECT: NOT running pass (215) Dead Store Elimination on function (negative_window)
CheckFunctionDebugify [Dead Store Elimination]: PASS
BISECT: NOT running pass (216) Aggressive Dead Code Elimination on function (negative_window)
CheckFunctionDebugify [Aggressive Dead Code Elimination]: PASS
BISECT: NOT running pass (217) Simplify the CFG on function (negative_window)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (218) Combine redundant instructions on function (negative_window)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (219) Remove unused exception handling info on SCC (llvm.dbg.value)
BISECT: NOT running pass (220) Deduce function attributes on SCC (llvm.dbg.value)
BISECT: NOT running pass (221) Remove unused exception handling info on SCC (<<null function>>)
BISECT: NOT running pass (222) Deduce function attributes on SCC (<<null function>>)
CheckModuleDebugify [A No-Op Barrier Pass]: PASS
BISECT: NOT running pass (223) Deduce function attributes in RPO on module (call-guard.ll)
CheckModuleDebugify [Deduce function attributes in RPO]: PASS
BISECT: NOT running pass (224) Global Variable Optimizer on module (call-guard.ll)
CheckModuleDebugify [Global Variable Optimizer]: PASS
BISECT: NOT running pass (225) Dead Global Elimination on module (call-guard.ll)
CheckModuleDebugify [Dead Global Elimination]: PASS
CheckModuleDebugify [Globals Alias Analysis]: PASS
BISECT: NOT running pass (226) Float to int on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Float to int]: PASS
BISECT: NOT running pass (227) Loop Distribution on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Loop Distribution]: PASS
BISECT: NOT running pass (228) Loop Vectorization on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Loop Vectorization]: PASS
BISECT: NOT running pass (229) Loop Load Elimination on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Loop Load Elimination]: PASS
BISECT: NOT running pass (230) Combine redundant instructions on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (231) Simplify the CFG on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (232) Combine redundant instructions on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (233) Combine redundant instructions on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (234) Warn about non-applied transformations on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Warn about non-applied transformations]: PASS
BISECT: NOT running pass (235) Alignment from assumptions on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Alignment from assumptions]: PASS
BISECT: NOT running pass (236) Float to int on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Float to int]: PASS
BISECT: NOT running pass (237) Loop Distribution on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Loop Distribution]: PASS
BISECT: NOT running pass (238) Loop Vectorization on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Loop Vectorization]: PASS
BISECT: NOT running pass (239) Loop Load Elimination on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Loop Load Elimination]: PASS
BISECT: NOT running pass (240) Combine redundant instructions on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (241) Simplify the CFG on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (242) Combine redundant instructions on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (243) Combine redundant instructions on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (244) Warn about non-applied transformations on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Warn about non-applied transformations]: PASS
BISECT: NOT running pass (245) Alignment from assumptions on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Alignment from assumptions]: PASS
BISECT: NOT running pass (246) Float to int on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Float to int]: PASS
BISECT: NOT running pass (247) Loop Distribution on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Loop Distribution]: PASS
BISECT: NOT running pass (248) Loop Vectorization on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Loop Vectorization]: PASS
BISECT: NOT running pass (249) Loop Load Elimination on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Loop Load Elimination]: PASS
BISECT: NOT running pass (250) Combine redundant instructions on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (251) Simplify the CFG on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (252) Combine redundant instructions on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (253) Combine redundant instructions on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (254) Warn about non-applied transformations on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Warn about non-applied transformations]: PASS
BISECT: NOT running pass (255) Alignment from assumptions on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Alignment from assumptions]: PASS
BISECT: NOT running pass (256) Float to int on function (negative_load)
CheckFunctionDebugify [Float to int]: PASS
BISECT: NOT running pass (257) Loop Distribution on function (negative_load)
CheckFunctionDebugify [Loop Distribution]: PASS
BISECT: NOT running pass (258) Loop Vectorization on function (negative_load)
CheckFunctionDebugify [Loop Vectorization]: PASS
BISECT: NOT running pass (259) Loop Load Elimination on function (negative_load)
CheckFunctionDebugify [Loop Load Elimination]: PASS
BISECT: NOT running pass (260) Combine redundant instructions on function (negative_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (261) Simplify the CFG on function (negative_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (262) Combine redundant instructions on function (negative_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (263) Combine redundant instructions on function (negative_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (264) Warn about non-applied transformations on function (negative_load)
CheckFunctionDebugify [Warn about non-applied transformations]: PASS
BISECT: NOT running pass (265) Alignment from assumptions on function (negative_load)
CheckFunctionDebugify [Alignment from assumptions]: PASS
BISECT: NOT running pass (266) Float to int on function (deref_load)
CheckFunctionDebugify [Float to int]: PASS
BISECT: NOT running pass (267) Loop Distribution on function (deref_load)
CheckFunctionDebugify [Loop Distribution]: PASS
BISECT: NOT running pass (268) Loop Vectorization on function (deref_load)
CheckFunctionDebugify [Loop Vectorization]: PASS
BISECT: NOT running pass (269) Loop Load Elimination on function (deref_load)
CheckFunctionDebugify [Loop Load Elimination]: PASS
BISECT: NOT running pass (270) Combine redundant instructions on function (deref_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (271) Simplify the CFG on function (deref_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (272) Combine redundant instructions on function (deref_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (273) Combine redundant instructions on function (deref_load)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (274) Warn about non-applied transformations on function (deref_load)
CheckFunctionDebugify [Warn about non-applied transformations]: PASS
BISECT: NOT running pass (275) Alignment from assumptions on function (deref_load)
CheckFunctionDebugify [Alignment from assumptions]: PASS
BISECT: NOT running pass (276) Float to int on function (negative_div)
CheckFunctionDebugify [Float to int]: PASS
BISECT: NOT running pass (277) Loop Distribution on function (negative_div)
CheckFunctionDebugify [Loop Distribution]: PASS
BISECT: NOT running pass (278) Loop Vectorization on function (negative_div)
CheckFunctionDebugify [Loop Vectorization]: PASS
BISECT: NOT running pass (279) Loop Load Elimination on function (negative_div)
CheckFunctionDebugify [Loop Load Elimination]: PASS
BISECT: NOT running pass (280) Combine redundant instructions on function (negative_div)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (281) Simplify the CFG on function (negative_div)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (282) Combine redundant instructions on function (negative_div)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (283) Combine redundant instructions on function (negative_div)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (284) Warn about non-applied transformations on function (negative_div)
CheckFunctionDebugify [Warn about non-applied transformations]: PASS
BISECT: NOT running pass (285) Alignment from assumptions on function (negative_div)
CheckFunctionDebugify [Alignment from assumptions]: PASS
BISECT: NOT running pass (286) Float to int on function (negative_window)
CheckFunctionDebugify [Float to int]: PASS
BISECT: NOT running pass (287) Loop Distribution on function (negative_window)
CheckFunctionDebugify [Loop Distribution]: PASS
BISECT: NOT running pass (288) Loop Vectorization on function (negative_window)
CheckFunctionDebugify [Loop Vectorization]: PASS
BISECT: NOT running pass (289) Loop Load Elimination on function (negative_window)
CheckFunctionDebugify [Loop Load Elimination]: PASS
BISECT: NOT running pass (290) Combine redundant instructions on function (negative_window)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (291) Simplify the CFG on function (negative_window)
CheckFunctionDebugify [Simplify the CFG]: PASS
BISECT: NOT running pass (292) Combine redundant instructions on function (negative_window)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (293) Combine redundant instructions on function (negative_window)
CheckFunctionDebugify [Combine redundant instructions]: PASS
BISECT: NOT running pass (294) Warn about non-applied transformations on function (negative_window)
CheckFunctionDebugify [Warn about non-applied transformations]: PASS
BISECT: NOT running pass (295) Alignment from assumptions on function (negative_window)
CheckFunctionDebugify [Alignment from assumptions]: PASS
BISECT: NOT running pass (296) Strip Unused Function Prototypes on module (call-guard.ll)
CheckModuleDebugify [Strip Unused Function Prototypes]: PASS
BISECT: NOT running pass (297) Remove redundant instructions on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Remove redundant instructions]: PASS
BISECT: NOT running pass (298) Hoist/decompose integer division and remainder on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Hoist/decompose integer division and remainder]: PASS
BISECT: NOT running pass (299) Simplify the CFG on function (test_guard_adjacent_same_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
CheckFunctionDebugify [Module Verifier]: PASS
BISECT: NOT running pass (300) Remove redundant instructions on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Remove redundant instructions]: PASS
BISECT: NOT running pass (301) Hoist/decompose integer division and remainder on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Hoist/decompose integer division and remainder]: PASS
BISECT: NOT running pass (302) Simplify the CFG on function (test_guard_adjacent_diff_cond)
CheckFunctionDebugify [Simplify the CFG]: PASS
CheckFunctionDebugify [Module Verifier]: PASS
BISECT: NOT running pass (303) Remove redundant instructions on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Remove redundant instructions]: PASS
BISECT: NOT running pass (304) Hoist/decompose integer division and remainder on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Hoist/decompose integer division and remainder]: PASS
BISECT: NOT running pass (305) Simplify the CFG on function (test_guard_adjacent_diff_cond2)
CheckFunctionDebugify [Simplify the CFG]: PASS
CheckFunctionDebugify [Module Verifier]: PASS
BISECT: NOT running pass (306) Remove redundant instructions on function (negative_load)
CheckFunctionDebugify [Remove redundant instructions]: PASS
BISECT: NOT running pass (307) Hoist/decompose integer division and remainder on function (negative_load)
CheckFunctionDebugify [Hoist/decompose integer division and remainder]: PASS
BISECT: NOT running pass (308) Simplify the CFG on function (negative_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
CheckFunctionDebugify [Module Verifier]: PASS
BISECT: NOT running pass (309) Remove redundant instructions on function (deref_load)
CheckFunctionDebugify [Remove redundant instructions]: PASS
BISECT: NOT running pass (310) Hoist/decompose integer division and remainder on function (deref_load)
CheckFunctionDebugify [Hoist/decompose integer division and remainder]: PASS
BISECT: NOT running pass (311) Simplify the CFG on function (deref_load)
CheckFunctionDebugify [Simplify the CFG]: PASS
CheckFunctionDebugify [Module Verifier]: PASS
BISECT: NOT running pass (312) Remove redundant instructions on function (negative_div)
CheckFunctionDebugify [Remove redundant instructions]: PASS
BISECT: NOT running pass (313) Hoist/decompose integer division and remainder on function (negative_div)
CheckFunctionDebugify [Hoist/decompose integer division and remainder]: PASS
BISECT: NOT running pass (314) Simplify the CFG on function (negative_div)
CheckFunctionDebugify [Simplify the CFG]: PASS
CheckFunctionDebugify [Module Verifier]: PASS
BISECT: NOT running pass (315) Remove redundant instructions on function (negative_window)
CheckFunctionDebugify [Remove redundant instructions]: PASS
BISECT: NOT running pass (316) Hoist/decompose integer division and remainder on function (negative_window)
CheckFunctionDebugify [Hoist/decompose integer division and remainder]: PASS
BISECT: NOT running pass (317) Simplify the CFG on function (negative_window)
CheckFunctionDebugify [Simplify the CFG]: PASS
CheckFunctionDebugify [Module Verifier]: PASS
